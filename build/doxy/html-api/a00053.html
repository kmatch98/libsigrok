<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libsigrok: include/libsigrok/proto.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="libsigrok_112x112.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libsigrok
   &#160;<span id="projectnumber">unreleased development snapshot</span>
   </div>
   <div id="projectbrief">sigrok hardware access and backend library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_ba065e053705d2107dee5ef032dbb411.html">libsigrok</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">proto.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Header file containing API function prototypes.  
<a href="#details">More...</a></p>
<div class="textblock"><div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> This graph shows which files directly or indirectly include this file:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="a00055.png" border="0" usemap="#ainclude_2libsigrok_2proto_8hdep" alt=""/></div>
<map name="ainclude_2libsigrok_2proto_8hdep" id="ainclude_2libsigrok_2proto_8hdep">
<area shape="rect" title="Header file containing API function prototypes." alt="" coords="1074,5,1233,32"/>
<area shape="rect" href="a00050.html" title="The public libsigrok header file to be used by frontends." alt="" coords="1064,80,1243,107"/>
<area shape="rect" href="a00002.html" title="Handling and converting analog data." alt="" coords="5,155,99,181"/>
<area shape="rect" href="a00005.html" title="Initializing and shutting down libsigrok." alt="" coords="123,155,227,181"/>
<area shape="rect" href="a00008.html" title=" " alt="" coords="251,155,389,181"/>
<area shape="rect" href="a00011.html" title="Conversion helper functions." alt="" coords="414,155,533,181"/>
<area shape="rect" href="a00014.html" title=" " alt="" coords="557,155,630,181"/>
<area shape="rect" href="a00017.html" title="Device handling in libsigrok." alt="" coords="655,155,748,181"/>
<area shape="rect" href="a00020.html" title="Error handling in libsigrok." alt="" coords="772,155,852,181"/>
<area shape="rect" href="a00023.html" title="Hardware driver handling in libsigrok." alt="" coords="877,155,979,181"/>
<area shape="rect" href="a00026.html" title="Controlling the libsigrok message logging functionality." alt="" coords="1004,155,1076,181"/>
<area shape="rect" href="a00029.html" title="Access to resource files." alt="" coords="1101,155,1206,181"/>
<area shape="rect" href="a00032.html" title="Serial port handling." alt="" coords="1230,155,1317,181"/>
<area shape="rect" href="a00035.html" title="Creating, using, or destroying libsigrok sessions." alt="" coords="1341,155,1441,181"/>
<area shape="rect" href="a00038.html" title="Loading and saving libsigrok session files." alt="" coords="1465,155,1589,181"/>
<area shape="rect" href="a00041.html" title="Helper functions for handling or converting libsigrok&#45;related strings." alt="" coords="1613,155,1699,181"/>
<area shape="rect" href="a00044.html" title="Creating, using, or destroying triggers." alt="" coords="1724,155,1815,181"/>
<area shape="rect" href="a00047.html" title="Version number querying functions, definitions, and macros." alt="" coords="1839,155,1937,181"/>
<area shape="rect" href="a00059.html" title="Input module handling." alt="" coords="1961,155,2076,181"/>
<area shape="rect" href="a00062.html" title="Output module handling." alt="" coords="2100,155,2231,181"/>
<area shape="rect" href="a00065.html" title="Transform module handling." alt="" coords="2255,155,2425,181"/>
</map>
</div>
</div>
<p><a href="a00053_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a89f99efa4192e3bf48461c3bf178241b"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00053.html#a89f99efa4192e3bf48461c3bf178241b">sr_log_callback</a>) (void *cb_data, int loglevel, const char *format, va_list args)</td></tr>
<tr class="separator:a89f99efa4192e3bf48461c3bf178241b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a47dcc64d187d380133c1986fce7bfd"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00053.html#a5a47dcc64d187d380133c1986fce7bfd">sr_session_stopped_callback</a>) (void *data)</td></tr>
<tr class="separator:a5a47dcc64d187d380133c1986fce7bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe3dfadc282fa9e0cc1479a27feec66b"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00053.html#abe3dfadc282fa9e0cc1479a27feec66b">sr_datafeed_callback</a>) (const struct sr_dev_inst *sdi, const struct <a class="el" href="a00122.html">sr_datafeed_packet</a> *packet, void *cb_data)</td></tr>
<tr class="separator:abe3dfadc282fa9e0cc1479a27feec66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a752a7d3375e2685e90893b1089d63972"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00053.html#a752a7d3375e2685e90893b1089d63972">sr_resource_open_callback</a>) (struct <a class="el" href="a00158.html">sr_resource</a> *res, const char *name, void *cb_data)</td></tr>
<tr class="separator:a752a7d3375e2685e90893b1089d63972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a8a2ac69656aabe68b54dab38288af"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00053.html#a51a8a2ac69656aabe68b54dab38288af">sr_resource_close_callback</a>) (struct <a class="el" href="a00158.html">sr_resource</a> *res, void *cb_data)</td></tr>
<tr class="separator:a51a8a2ac69656aabe68b54dab38288af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa98b4fba926e47164a1701658efe2550"><td class="memItemLeft" align="right" valign="top">typedef gssize(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00053.html#aa98b4fba926e47164a1701658efe2550">sr_resource_read_callback</a>) (const struct <a class="el" href="a00158.html">sr_resource</a> *res, void *buf, size_t count, void *cb_data)</td></tr>
<tr class="separator:aa98b4fba926e47164a1701658efe2550"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7c692bc1d32dc9b126cd0d6bbf21f2bd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html#ga7c692bc1d32dc9b126cd0d6bbf21f2bd">sr_analog_to_float</a> (const struct <a class="el" href="a00138.html">sr_datafeed_analog</a> *analog, float *buf)</td></tr>
<tr class="memdesc:ga7c692bc1d32dc9b126cd0d6bbf21f2bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an analog datafeed payload to an array of floats.  <a href="a00069.html#ga7c692bc1d32dc9b126cd0d6bbf21f2bd">More...</a><br /></td></tr>
<tr class="separator:ga7c692bc1d32dc9b126cd0d6bbf21f2bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4605e40840772ded016b36e5ce938d6"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html#gad4605e40840772ded016b36e5ce938d6">sr_analog_si_prefix</a> (float *value, int *digits)</td></tr>
<tr class="memdesc:gad4605e40840772ded016b36e5ce938d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale a float value to the appropriate SI prefix.  <a href="a00069.html#gad4605e40840772ded016b36e5ce938d6">More...</a><br /></td></tr>
<tr class="separator:gad4605e40840772ded016b36e5ce938d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae286256e4f6420bbb1d426e23015479"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html#gaae286256e4f6420bbb1d426e23015479">sr_analog_si_prefix_friendly</a> (enum <a class="el" href="a00050.html#af13f9a5c3de811f4e120314aa8eb964c">sr_unit</a> unit)</td></tr>
<tr class="memdesc:gaae286256e4f6420bbb1d426e23015479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a unit "accepts" an SI prefix.  <a href="a00069.html#gaae286256e4f6420bbb1d426e23015479">More...</a><br /></td></tr>
<tr class="separator:gaae286256e4f6420bbb1d426e23015479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga849fde6f4ed4c75d12b7358cabe5a65d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html#ga849fde6f4ed4c75d12b7358cabe5a65d">sr_analog_unit_to_string</a> (const struct <a class="el" href="a00138.html">sr_datafeed_analog</a> *analog, char **result)</td></tr>
<tr class="memdesc:ga849fde6f4ed4c75d12b7358cabe5a65d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the unit/MQ/MQ flags in the analog struct to a string.  <a href="a00069.html#ga849fde6f4ed4c75d12b7358cabe5a65d">More...</a><br /></td></tr>
<tr class="separator:ga849fde6f4ed4c75d12b7358cabe5a65d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c1b8581323f334e9580b9a36d5a52fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html#ga1c1b8581323f334e9580b9a36d5a52fd">sr_rational_set</a> (struct <a class="el" href="a00118.html">sr_rational</a> *r, int64_t p, uint64_t q)</td></tr>
<tr class="memdesc:ga1c1b8581323f334e9580b9a36d5a52fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <a class="el" href="a00118.html">sr_rational</a> r to the given value.  <a href="a00069.html#ga1c1b8581323f334e9580b9a36d5a52fd">More...</a><br /></td></tr>
<tr class="separator:ga1c1b8581323f334e9580b9a36d5a52fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5f21f8d1f341bb0593316610668d973"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html#gaf5f21f8d1f341bb0593316610668d973">sr_rational_eq</a> (const struct <a class="el" href="a00118.html">sr_rational</a> *a, const struct <a class="el" href="a00118.html">sr_rational</a> *b)</td></tr>
<tr class="memdesc:gaf5f21f8d1f341bb0593316610668d973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="a00118.html">sr_rational</a> for equality.  <a href="a00069.html#gaf5f21f8d1f341bb0593316610668d973">More...</a><br /></td></tr>
<tr class="separator:gaf5f21f8d1f341bb0593316610668d973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ee05b9bac44087e25a0708da9c0359f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html#ga7ee05b9bac44087e25a0708da9c0359f">sr_rational_mult</a> (struct <a class="el" href="a00118.html">sr_rational</a> *res, const struct <a class="el" href="a00118.html">sr_rational</a> *a, const struct <a class="el" href="a00118.html">sr_rational</a> *b)</td></tr>
<tr class="memdesc:ga7ee05b9bac44087e25a0708da9c0359f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two <a class="el" href="a00118.html">sr_rational</a>.  <a href="a00069.html#ga7ee05b9bac44087e25a0708da9c0359f">More...</a><br /></td></tr>
<tr class="separator:ga7ee05b9bac44087e25a0708da9c0359f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b073bd224cb636ad043442cc8ad0c29"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html#ga1b073bd224cb636ad043442cc8ad0c29">sr_rational_div</a> (struct <a class="el" href="a00118.html">sr_rational</a> *res, const struct <a class="el" href="a00118.html">sr_rational</a> *num, const struct <a class="el" href="a00118.html">sr_rational</a> *div)</td></tr>
<tr class="memdesc:ga1b073bd224cb636ad043442cc8ad0c29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide rational a by rational b.  <a href="a00069.html#ga1b073bd224cb636ad043442cc8ad0c29">More...</a><br /></td></tr>
<tr class="separator:ga1b073bd224cb636ad043442cc8ad0c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6210982b018100246093873faf07a667"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#ga6210982b018100246093873faf07a667">sr_init</a> (struct <a class="el" href="a00186.html">sr_context</a> **ctx)</td></tr>
<tr class="memdesc:ga6210982b018100246093873faf07a667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize libsigrok.  <a href="a00070.html#ga6210982b018100246093873faf07a667">More...</a><br /></td></tr>
<tr class="separator:ga6210982b018100246093873faf07a667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94b41cf5bc8ccafad9fe4c1bd6d2cc41"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#ga94b41cf5bc8ccafad9fe4c1bd6d2cc41">sr_exit</a> (struct <a class="el" href="a00186.html">sr_context</a> *ctx)</td></tr>
<tr class="memdesc:ga94b41cf5bc8ccafad9fe4c1bd6d2cc41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shutdown libsigrok.  <a href="a00070.html#ga94b41cf5bc8ccafad9fe4c1bd6d2cc41">More...</a><br /></td></tr>
<tr class="separator:ga94b41cf5bc8ccafad9fe4c1bd6d2cc41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e5a750e64152a317a65dc4ced212ca3"><td class="memItemLeft" align="right" valign="top">GSList *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#ga6e5a750e64152a317a65dc4ced212ca3">sr_buildinfo_libs_get</a> (void)</td></tr>
<tr class="separator:ga6e5a750e64152a317a65dc4ced212ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga503329dffe42e5646c0441d8199ebcb4"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#ga503329dffe42e5646c0441d8199ebcb4">sr_buildinfo_host_get</a> (void)</td></tr>
<tr class="separator:ga503329dffe42e5646c0441d8199ebcb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb7312d59de7a1467c0c7195e3012af4"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#gadb7312d59de7a1467c0c7195e3012af4">sr_buildinfo_scpi_backends_get</a> (void)</td></tr>
<tr class="separator:gadb7312d59de7a1467c0c7195e3012af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f168ba982a19fb0e51254d5852e6572"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00053.html#a3f168ba982a19fb0e51254d5852e6572">sr_a2l_threshold</a> (const struct <a class="el" href="a00138.html">sr_datafeed_analog</a> *analog, float threshold, uint8_t *output, uint64_t count)</td></tr>
<tr class="memdesc:a3f168ba982a19fb0e51254d5852e6572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert analog values to logic values by using a fixed threshold.  <a href="a00053.html#a3f168ba982a19fb0e51254d5852e6572">More...</a><br /></td></tr>
<tr class="separator:a3f168ba982a19fb0e51254d5852e6572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae077d85c8390eff878bf7d096d929a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00053.html#abae077d85c8390eff878bf7d096d929a">sr_a2l_schmitt_trigger</a> (const struct <a class="el" href="a00138.html">sr_datafeed_analog</a> *analog, float lo_thr, float hi_thr, uint8_t *state, uint8_t *output, uint64_t count)</td></tr>
<tr class="memdesc:abae077d85c8390eff878bf7d096d929a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert analog values to logic values by using a Schmitt-trigger algorithm.  <a href="a00053.html#abae077d85c8390eff878bf7d096d929a">More...</a><br /></td></tr>
<tr class="separator:abae077d85c8390eff878bf7d096d929a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2eff466cec6a339d9a147eac65b74a97"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00074.html#ga2eff466cec6a339d9a147eac65b74a97">sr_log_loglevel_set</a> (int loglevel)</td></tr>
<tr class="memdesc:ga2eff466cec6a339d9a147eac65b74a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the libsigrok loglevel.  <a href="a00074.html#ga2eff466cec6a339d9a147eac65b74a97">More...</a><br /></td></tr>
<tr class="separator:ga2eff466cec6a339d9a147eac65b74a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5039ee00076e2deead00f8c14d9063fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00074.html#ga5039ee00076e2deead00f8c14d9063fe">sr_log_loglevel_get</a> (void)</td></tr>
<tr class="memdesc:ga5039ee00076e2deead00f8c14d9063fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the libsigrok loglevel.  <a href="a00074.html#ga5039ee00076e2deead00f8c14d9063fe">More...</a><br /></td></tr>
<tr class="separator:ga5039ee00076e2deead00f8c14d9063fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4240b8fe79be72ef758f40f9acbd4316"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00074.html#ga4240b8fe79be72ef758f40f9acbd4316">sr_log_callback_set</a> (<a class="el" href="a00053.html#a89f99efa4192e3bf48461c3bf178241b">sr_log_callback</a> cb, void *cb_data)</td></tr>
<tr class="memdesc:ga4240b8fe79be72ef758f40f9acbd4316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the libsigrok log callback to the specified function.  <a href="a00074.html#ga4240b8fe79be72ef758f40f9acbd4316">More...</a><br /></td></tr>
<tr class="separator:ga4240b8fe79be72ef758f40f9acbd4316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7758b06f7eab52af8cf07b90a01a216"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00074.html#gae7758b06f7eab52af8cf07b90a01a216">sr_log_callback_set_default</a> (void)</td></tr>
<tr class="memdesc:gae7758b06f7eab52af8cf07b90a01a216"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the libsigrok log callback to the default built-in one.  <a href="a00074.html#gae7758b06f7eab52af8cf07b90a01a216">More...</a><br /></td></tr>
<tr class="separator:gae7758b06f7eab52af8cf07b90a01a216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad554aa783e2453ecdeb2d50e4be231c9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00074.html#gad554aa783e2453ecdeb2d50e4be231c9">sr_log_callback_get</a> (<a class="el" href="a00053.html#a89f99efa4192e3bf48461c3bf178241b">sr_log_callback</a> *cb, void **cb_data)</td></tr>
<tr class="memdesc:gad554aa783e2453ecdeb2d50e4be231c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the libsigrok log callback routine and callback data.  <a href="a00074.html#gad554aa783e2453ecdeb2d50e4be231c9">More...</a><br /></td></tr>
<tr class="separator:gad554aa783e2453ecdeb2d50e4be231c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd4d8d0d8548c03bb55a6683a835a036"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#gabd4d8d0d8548c03bb55a6683a835a036">sr_dev_channel_name_set</a> (struct <a class="el" href="a00162.html">sr_channel</a> *channel, const char *name)</td></tr>
<tr class="memdesc:gabd4d8d0d8548c03bb55a6683a835a036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the name of the specified channel.  <a href="a00071.html#gabd4d8d0d8548c03bb55a6683a835a036">More...</a><br /></td></tr>
<tr class="separator:gabd4d8d0d8548c03bb55a6683a835a036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01a44d3f7c1231b214940f363bbd5f1c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ga01a44d3f7c1231b214940f363bbd5f1c">sr_dev_channel_enable</a> (struct <a class="el" href="a00162.html">sr_channel</a> *channel, gboolean state)</td></tr>
<tr class="memdesc:ga01a44d3f7c1231b214940f363bbd5f1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable a channel.  <a href="a00071.html#ga01a44d3f7c1231b214940f363bbd5f1c">More...</a><br /></td></tr>
<tr class="separator:ga01a44d3f7c1231b214940f363bbd5f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8748df5e84b0785ccf26409e427f2375"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ga8748df5e84b0785ccf26409e427f2375">sr_dev_has_option</a> (const struct sr_dev_inst *sdi, int key)</td></tr>
<tr class="memdesc:ga8748df5e84b0785ccf26409e427f2375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the specified device instance has the specified capability.  <a href="a00071.html#ga8748df5e84b0785ccf26409e427f2375">More...</a><br /></td></tr>
<tr class="separator:ga8748df5e84b0785ccf26409e427f2375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafd19fdb190135fee018781ad4f95bb8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#gaafd19fdb190135fee018781ad4f95bb8">sr_dev_config_capabilities_list</a> (const struct sr_dev_inst *sdi, const struct <a class="el" href="a00166.html">sr_channel_group</a> *cg, int key)</td></tr>
<tr class="memdesc:gaafd19fdb190135fee018781ad4f95bb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerate the configuration capabilities supported by a device instance for a given configuration key.  <a href="a00071.html#gaafd19fdb190135fee018781ad4f95bb8">More...</a><br /></td></tr>
<tr class="separator:gaafd19fdb190135fee018781ad4f95bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26fee1c71ff0c486f93db5ee80c1e943"><td class="memItemLeft" align="right" valign="top">GArray *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ga26fee1c71ff0c486f93db5ee80c1e943">sr_dev_options</a> (const struct <a class="el" href="a00178.html">sr_dev_driver</a> *driver, const struct sr_dev_inst *sdi, const struct <a class="el" href="a00166.html">sr_channel_group</a> *cg)</td></tr>
<tr class="memdesc:ga26fee1c71ff0c486f93db5ee80c1e943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerate the configuration options of the specified item.  <a href="a00071.html#ga26fee1c71ff0c486f93db5ee80c1e943">More...</a><br /></td></tr>
<tr class="separator:ga26fee1c71ff0c486f93db5ee80c1e943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6973a5d7c159e588211a287d716aa26"><td class="memItemLeft" align="right" valign="top">GSList *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#gaf6973a5d7c159e588211a287d716aa26">sr_dev_list</a> (const struct <a class="el" href="a00178.html">sr_dev_driver</a> *driver)</td></tr>
<tr class="memdesc:gaf6973a5d7c159e588211a287d716aa26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of devices/instances of the specified driver.  <a href="a00071.html#gaf6973a5d7c159e588211a287d716aa26">More...</a><br /></td></tr>
<tr class="separator:gaf6973a5d7c159e588211a287d716aa26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga757ef4b2ca0d6be7098fa2b6f87e1995"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ga757ef4b2ca0d6be7098fa2b6f87e1995">sr_dev_clear</a> (const struct <a class="el" href="a00178.html">sr_dev_driver</a> *driver)</td></tr>
<tr class="memdesc:ga757ef4b2ca0d6be7098fa2b6f87e1995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the list of device instances a driver knows about.  <a href="a00071.html#ga757ef4b2ca0d6be7098fa2b6f87e1995">More...</a><br /></td></tr>
<tr class="separator:ga757ef4b2ca0d6be7098fa2b6f87e1995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb8d2f9296376e2223d1c23d04de5cf2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#gabb8d2f9296376e2223d1c23d04de5cf2">sr_dev_open</a> (struct sr_dev_inst *sdi)</td></tr>
<tr class="memdesc:gabb8d2f9296376e2223d1c23d04de5cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open the specified device instance.  <a href="a00071.html#gabb8d2f9296376e2223d1c23d04de5cf2">More...</a><br /></td></tr>
<tr class="separator:gabb8d2f9296376e2223d1c23d04de5cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64973860ad236d001ee8f45d09b98372"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ga64973860ad236d001ee8f45d09b98372">sr_dev_close</a> (struct sr_dev_inst *sdi)</td></tr>
<tr class="memdesc:ga64973860ad236d001ee8f45d09b98372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the specified device instance.  <a href="a00071.html#ga64973860ad236d001ee8f45d09b98372">More...</a><br /></td></tr>
<tr class="separator:ga64973860ad236d001ee8f45d09b98372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac54ac663464d994e07681e7566f3b068"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="a00178.html">sr_dev_driver</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#gac54ac663464d994e07681e7566f3b068">sr_dev_inst_driver_get</a> (const struct sr_dev_inst *sdi)</td></tr>
<tr class="memdesc:gac54ac663464d994e07681e7566f3b068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries a device instances' driver.  <a href="a00071.html#gac54ac663464d994e07681e7566f3b068">More...</a><br /></td></tr>
<tr class="separator:gac54ac663464d994e07681e7566f3b068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga666849e9e179e21e2cd263311a49b100"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ga666849e9e179e21e2cd263311a49b100">sr_dev_inst_vendor_get</a> (const struct sr_dev_inst *sdi)</td></tr>
<tr class="memdesc:ga666849e9e179e21e2cd263311a49b100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries a device instances' vendor.  <a href="a00071.html#ga666849e9e179e21e2cd263311a49b100">More...</a><br /></td></tr>
<tr class="separator:ga666849e9e179e21e2cd263311a49b100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cf89172ac7c3110348fec441e3e4119"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ga0cf89172ac7c3110348fec441e3e4119">sr_dev_inst_model_get</a> (const struct sr_dev_inst *sdi)</td></tr>
<tr class="memdesc:ga0cf89172ac7c3110348fec441e3e4119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries a device instances' model.  <a href="a00071.html#ga0cf89172ac7c3110348fec441e3e4119">More...</a><br /></td></tr>
<tr class="separator:ga0cf89172ac7c3110348fec441e3e4119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cd7545b8254c6f5b1150b43f3fd406f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ga8cd7545b8254c6f5b1150b43f3fd406f">sr_dev_inst_version_get</a> (const struct sr_dev_inst *sdi)</td></tr>
<tr class="memdesc:ga8cd7545b8254c6f5b1150b43f3fd406f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries a device instances' version.  <a href="a00071.html#ga8cd7545b8254c6f5b1150b43f3fd406f">More...</a><br /></td></tr>
<tr class="separator:ga8cd7545b8254c6f5b1150b43f3fd406f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dadb80a5ebe2fef6be0369c8bcb7ee4"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ga7dadb80a5ebe2fef6be0369c8bcb7ee4">sr_dev_inst_sernum_get</a> (const struct sr_dev_inst *sdi)</td></tr>
<tr class="memdesc:ga7dadb80a5ebe2fef6be0369c8bcb7ee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries a device instances' serial number.  <a href="a00071.html#ga7dadb80a5ebe2fef6be0369c8bcb7ee4">More...</a><br /></td></tr>
<tr class="separator:ga7dadb80a5ebe2fef6be0369c8bcb7ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77f128263c50a618983c360185229115"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ga77f128263c50a618983c360185229115">sr_dev_inst_connid_get</a> (const struct sr_dev_inst *sdi)</td></tr>
<tr class="memdesc:ga77f128263c50a618983c360185229115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries a device instances' connection identifier.  <a href="a00071.html#ga77f128263c50a618983c360185229115">More...</a><br /></td></tr>
<tr class="separator:ga77f128263c50a618983c360185229115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fd62dba1ab23181dd5f3515ce244c54"><td class="memItemLeft" align="right" valign="top">GSList *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ga7fd62dba1ab23181dd5f3515ce244c54">sr_dev_inst_channels_get</a> (const struct sr_dev_inst *sdi)</td></tr>
<tr class="memdesc:ga7fd62dba1ab23181dd5f3515ce244c54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries a device instances' channel list.  <a href="a00071.html#ga7fd62dba1ab23181dd5f3515ce244c54">More...</a><br /></td></tr>
<tr class="separator:ga7fd62dba1ab23181dd5f3515ce244c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2a2914e066fc3c405836445ecdd9ca4"><td class="memItemLeft" align="right" valign="top">GSList *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#gad2a2914e066fc3c405836445ecdd9ca4">sr_dev_inst_channel_groups_get</a> (const struct sr_dev_inst *sdi)</td></tr>
<tr class="memdesc:gad2a2914e066fc3c405836445ecdd9ca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries a device instances' channel groups list.  <a href="a00071.html#gad2a2914e066fc3c405836445ecdd9ca4">More...</a><br /></td></tr>
<tr class="separator:gad2a2914e066fc3c405836445ecdd9ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11dcc1cfb14c582a5cc683a08bb5da65"><td class="memItemLeft" align="right" valign="top">struct sr_dev_inst *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ga11dcc1cfb14c582a5cc683a08bb5da65">sr_dev_inst_user_new</a> (const char *vendor, const char *model, const char *version)</td></tr>
<tr class="memdesc:ga11dcc1cfb14c582a5cc683a08bb5da65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and init a new user-generated device instance.  <a href="a00071.html#ga11dcc1cfb14c582a5cc683a08bb5da65">More...</a><br /></td></tr>
<tr class="separator:ga11dcc1cfb14c582a5cc683a08bb5da65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c038a70b39b7465e74f1954be8d4c60"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ga8c038a70b39b7465e74f1954be8d4c60">sr_dev_inst_channel_add</a> (struct sr_dev_inst *sdi, int index, int type, const char *name)</td></tr>
<tr class="memdesc:ga8c038a70b39b7465e74f1954be8d4c60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new channel to the specified device instance.  <a href="a00071.html#ga8c038a70b39b7465e74f1954be8d4c60">More...</a><br /></td></tr>
<tr class="separator:ga8c038a70b39b7465e74f1954be8d4c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga755e937630acf9037eff1938233782c8"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="a00178.html">sr_dev_driver</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00073.html#ga755e937630acf9037eff1938233782c8">sr_driver_list</a> (const struct <a class="el" href="a00186.html">sr_context</a> *ctx)</td></tr>
<tr class="memdesc:ga755e937630acf9037eff1938233782c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the list of supported hardware drivers.  <a href="a00073.html#ga755e937630acf9037eff1938233782c8">More...</a><br /></td></tr>
<tr class="separator:ga755e937630acf9037eff1938233782c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33ced36993359a47eae8810f79737976"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00073.html#ga33ced36993359a47eae8810f79737976">sr_driver_init</a> (struct <a class="el" href="a00186.html">sr_context</a> *ctx, struct <a class="el" href="a00178.html">sr_dev_driver</a> *driver)</td></tr>
<tr class="memdesc:ga33ced36993359a47eae8810f79737976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a hardware driver.  <a href="a00073.html#ga33ced36993359a47eae8810f79737976">More...</a><br /></td></tr>
<tr class="separator:ga33ced36993359a47eae8810f79737976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bfdb365f409063a682928716f8c3c3f"><td class="memItemLeft" align="right" valign="top">GArray *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00073.html#ga8bfdb365f409063a682928716f8c3c3f">sr_driver_scan_options_list</a> (const struct <a class="el" href="a00178.html">sr_dev_driver</a> *driver)</td></tr>
<tr class="memdesc:ga8bfdb365f409063a682928716f8c3c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerate scan options supported by this driver.  <a href="a00073.html#ga8bfdb365f409063a682928716f8c3c3f">More...</a><br /></td></tr>
<tr class="separator:ga8bfdb365f409063a682928716f8c3c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga997c1db14dae8faef0865b6331d52bdd"><td class="memItemLeft" align="right" valign="top">GSList *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00073.html#ga997c1db14dae8faef0865b6331d52bdd">sr_driver_scan</a> (struct <a class="el" href="a00178.html">sr_dev_driver</a> *driver, GSList *options)</td></tr>
<tr class="memdesc:ga997c1db14dae8faef0865b6331d52bdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell a hardware driver to scan for devices.  <a href="a00073.html#ga997c1db14dae8faef0865b6331d52bdd">More...</a><br /></td></tr>
<tr class="separator:ga997c1db14dae8faef0865b6331d52bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc6131f95a0a1198355a4f013200ad7b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00073.html#gabc6131f95a0a1198355a4f013200ad7b">sr_config_get</a> (const struct <a class="el" href="a00178.html">sr_dev_driver</a> *driver, const struct sr_dev_inst *sdi, const struct <a class="el" href="a00166.html">sr_channel_group</a> *cg, uint32_t key, GVariant **data)</td></tr>
<tr class="memdesc:gabc6131f95a0a1198355a4f013200ad7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query value of a configuration key at the given driver or device instance.  <a href="a00073.html#gabc6131f95a0a1198355a4f013200ad7b">More...</a><br /></td></tr>
<tr class="separator:gabc6131f95a0a1198355a4f013200ad7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17f18fc144eeb667f2fd596948426941"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00073.html#ga17f18fc144eeb667f2fd596948426941">sr_config_set</a> (const struct sr_dev_inst *sdi, const struct <a class="el" href="a00166.html">sr_channel_group</a> *cg, uint32_t key, GVariant *data)</td></tr>
<tr class="memdesc:ga17f18fc144eeb667f2fd596948426941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set value of a configuration key in a device instance.  <a href="a00073.html#ga17f18fc144eeb667f2fd596948426941">More...</a><br /></td></tr>
<tr class="separator:ga17f18fc144eeb667f2fd596948426941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga392e481fc872786f871b5c7ce3934087"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00073.html#ga392e481fc872786f871b5c7ce3934087">sr_config_commit</a> (const struct sr_dev_inst *sdi)</td></tr>
<tr class="memdesc:ga392e481fc872786f871b5c7ce3934087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply configuration settings to the device hardware.  <a href="a00073.html#ga392e481fc872786f871b5c7ce3934087">More...</a><br /></td></tr>
<tr class="separator:ga392e481fc872786f871b5c7ce3934087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac72c02a32f953728715973412be0bc6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00073.html#gaac72c02a32f953728715973412be0bc6">sr_config_list</a> (const struct <a class="el" href="a00178.html">sr_dev_driver</a> *driver, const struct sr_dev_inst *sdi, const struct <a class="el" href="a00166.html">sr_channel_group</a> *cg, uint32_t key, GVariant **data)</td></tr>
<tr class="memdesc:gaac72c02a32f953728715973412be0bc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">List all possible values for a configuration key.  <a href="a00073.html#gaac72c02a32f953728715973412be0bc6">More...</a><br /></td></tr>
<tr class="separator:gaac72c02a32f953728715973412be0bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbe481f247af711cbd6902d9a3120cb6"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="a00174.html">sr_key_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00073.html#gafbe481f247af711cbd6902d9a3120cb6">sr_key_info_get</a> (int keytype, uint32_t key)</td></tr>
<tr class="memdesc:gafbe481f247af711cbd6902d9a3120cb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get information about a key, by key.  <a href="a00073.html#gafbe481f247af711cbd6902d9a3120cb6">More...</a><br /></td></tr>
<tr class="separator:gafbe481f247af711cbd6902d9a3120cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac033a6db6a21346591a068d90ee8fae4"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="a00174.html">sr_key_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00073.html#gac033a6db6a21346591a068d90ee8fae4">sr_key_info_name_get</a> (int keytype, const char *keyid)</td></tr>
<tr class="memdesc:gac033a6db6a21346591a068d90ee8fae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get information about a key, by name.  <a href="a00073.html#gac033a6db6a21346591a068d90ee8fae4">More...</a><br /></td></tr>
<tr class="separator:gac033a6db6a21346591a068d90ee8fae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b2382d16a6b005f7d22e77b78cc32ec"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="a00106.html">sr_trigger</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00076.html#ga9b2382d16a6b005f7d22e77b78cc32ec">sr_session_trigger_get</a> (struct <a class="el" href="a00190.html">sr_session</a> *session)</td></tr>
<tr class="memdesc:ga9b2382d16a6b005f7d22e77b78cc32ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the trigger assigned to this session.  <a href="a00076.html#ga9b2382d16a6b005f7d22e77b78cc32ec">More...</a><br /></td></tr>
<tr class="separator:ga9b2382d16a6b005f7d22e77b78cc32ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c71ff4871df5448ae3c6a6f2e1a7bfd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00076.html#ga2c71ff4871df5448ae3c6a6f2e1a7bfd">sr_session_load</a> (struct <a class="el" href="a00186.html">sr_context</a> *ctx, const char *filename, struct <a class="el" href="a00190.html">sr_session</a> **session)</td></tr>
<tr class="memdesc:ga2c71ff4871df5448ae3c6a6f2e1a7bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the session from the specified filename.  <a href="a00076.html#ga2c71ff4871df5448ae3c6a6f2e1a7bfd">More...</a><br /></td></tr>
<tr class="separator:ga2c71ff4871df5448ae3c6a6f2e1a7bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83de7a88c9e1a41be0a421669369dbd0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00076.html#ga83de7a88c9e1a41be0a421669369dbd0">sr_session_new</a> (struct <a class="el" href="a00186.html">sr_context</a> *ctx, struct <a class="el" href="a00190.html">sr_session</a> **session)</td></tr>
<tr class="memdesc:ga83de7a88c9e1a41be0a421669369dbd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new session.  <a href="a00076.html#ga83de7a88c9e1a41be0a421669369dbd0">More...</a><br /></td></tr>
<tr class="separator:ga83de7a88c9e1a41be0a421669369dbd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1b7200161c362ee2fc5c0fe88586462"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00076.html#gaf1b7200161c362ee2fc5c0fe88586462">sr_session_destroy</a> (struct <a class="el" href="a00190.html">sr_session</a> *session)</td></tr>
<tr class="memdesc:gaf1b7200161c362ee2fc5c0fe88586462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a session.  <a href="a00076.html#gaf1b7200161c362ee2fc5c0fe88586462">More...</a><br /></td></tr>
<tr class="separator:gaf1b7200161c362ee2fc5c0fe88586462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad77b8c141a6e158fa474d6e9281ca77c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00076.html#gad77b8c141a6e158fa474d6e9281ca77c">sr_session_dev_remove_all</a> (struct <a class="el" href="a00190.html">sr_session</a> *session)</td></tr>
<tr class="memdesc:gad77b8c141a6e158fa474d6e9281ca77c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all the devices from a session.  <a href="a00076.html#gad77b8c141a6e158fa474d6e9281ca77c">More...</a><br /></td></tr>
<tr class="separator:gad77b8c141a6e158fa474d6e9281ca77c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac037d037baecc2b3679044d2b7c3bad3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00076.html#gac037d037baecc2b3679044d2b7c3bad3">sr_session_dev_add</a> (struct <a class="el" href="a00190.html">sr_session</a> *session, struct sr_dev_inst *sdi)</td></tr>
<tr class="memdesc:gac037d037baecc2b3679044d2b7c3bad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a device instance to a session.  <a href="a00076.html#gac037d037baecc2b3679044d2b7c3bad3">More...</a><br /></td></tr>
<tr class="separator:gac037d037baecc2b3679044d2b7c3bad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad08ce13c738a985321596778bfc22273"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00076.html#gad08ce13c738a985321596778bfc22273">sr_session_dev_remove</a> (struct <a class="el" href="a00190.html">sr_session</a> *session, struct sr_dev_inst *sdi)</td></tr>
<tr class="memdesc:gad08ce13c738a985321596778bfc22273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a device instance from a session.  <a href="a00076.html#gad08ce13c738a985321596778bfc22273">More...</a><br /></td></tr>
<tr class="separator:gad08ce13c738a985321596778bfc22273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0753ea59f6f7f2f99bf6de35fab72400"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00076.html#ga0753ea59f6f7f2f99bf6de35fab72400">sr_session_dev_list</a> (struct <a class="el" href="a00190.html">sr_session</a> *session, GSList **devlist)</td></tr>
<tr class="memdesc:ga0753ea59f6f7f2f99bf6de35fab72400"><td class="mdescLeft">&#160;</td><td class="mdescRight">List all device instances attached to a session.  <a href="a00076.html#ga0753ea59f6f7f2f99bf6de35fab72400">More...</a><br /></td></tr>
<tr class="separator:ga0753ea59f6f7f2f99bf6de35fab72400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a72faea3441cb5e9e42079ecb2f4651"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00076.html#ga0a72faea3441cb5e9e42079ecb2f4651">sr_session_trigger_set</a> (struct <a class="el" href="a00190.html">sr_session</a> *session, struct <a class="el" href="a00106.html">sr_trigger</a> *trig)</td></tr>
<tr class="memdesc:ga0a72faea3441cb5e9e42079ecb2f4651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the trigger of this session.  <a href="a00076.html#ga0a72faea3441cb5e9e42079ecb2f4651">More...</a><br /></td></tr>
<tr class="separator:ga0a72faea3441cb5e9e42079ecb2f4651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga184a47240fd2a77038df65e85b7cd356"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00076.html#ga184a47240fd2a77038df65e85b7cd356">sr_session_datafeed_callback_remove_all</a> (struct <a class="el" href="a00190.html">sr_session</a> *session)</td></tr>
<tr class="memdesc:ga184a47240fd2a77038df65e85b7cd356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all datafeed callbacks in a session.  <a href="a00076.html#ga184a47240fd2a77038df65e85b7cd356">More...</a><br /></td></tr>
<tr class="separator:ga184a47240fd2a77038df65e85b7cd356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8675ef7da27e7dd4a54a2c09371272a2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00076.html#ga8675ef7da27e7dd4a54a2c09371272a2">sr_session_datafeed_callback_add</a> (struct <a class="el" href="a00190.html">sr_session</a> *session, <a class="el" href="a00053.html#abe3dfadc282fa9e0cc1479a27feec66b">sr_datafeed_callback</a> cb, void *cb_data)</td></tr>
<tr class="memdesc:ga8675ef7da27e7dd4a54a2c09371272a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a datafeed callback to a session.  <a href="a00076.html#ga8675ef7da27e7dd4a54a2c09371272a2">More...</a><br /></td></tr>
<tr class="separator:ga8675ef7da27e7dd4a54a2c09371272a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac6e5af8f883193213a60b21f9f16432"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00076.html#gaac6e5af8f883193213a60b21f9f16432">sr_session_start</a> (struct <a class="el" href="a00190.html">sr_session</a> *session)</td></tr>
<tr class="memdesc:gaac6e5af8f883193213a60b21f9f16432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a session.  <a href="a00076.html#gaac6e5af8f883193213a60b21f9f16432">More...</a><br /></td></tr>
<tr class="separator:gaac6e5af8f883193213a60b21f9f16432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga183fd38711238188c9cd798684a867dd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00076.html#ga183fd38711238188c9cd798684a867dd">sr_session_run</a> (struct <a class="el" href="a00190.html">sr_session</a> *session)</td></tr>
<tr class="memdesc:ga183fd38711238188c9cd798684a867dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block until the running session stops.  <a href="a00076.html#ga183fd38711238188c9cd798684a867dd">More...</a><br /></td></tr>
<tr class="separator:ga183fd38711238188c9cd798684a867dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d7668d5dc7dce074cc427d847283d93"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00076.html#ga5d7668d5dc7dce074cc427d847283d93">sr_session_stop</a> (struct <a class="el" href="a00190.html">sr_session</a> *session)</td></tr>
<tr class="memdesc:ga5d7668d5dc7dce074cc427d847283d93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop a session.  <a href="a00076.html#ga5d7668d5dc7dce074cc427d847283d93">More...</a><br /></td></tr>
<tr class="separator:ga5d7668d5dc7dce074cc427d847283d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga030b75ad7e5736f34ff1961fe48c7a7e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00076.html#ga030b75ad7e5736f34ff1961fe48c7a7e">sr_session_is_running</a> (struct <a class="el" href="a00190.html">sr_session</a> *session)</td></tr>
<tr class="memdesc:ga030b75ad7e5736f34ff1961fe48c7a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether the session is currently running.  <a href="a00076.html#ga030b75ad7e5736f34ff1961fe48c7a7e">More...</a><br /></td></tr>
<tr class="separator:ga030b75ad7e5736f34ff1961fe48c7a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba31aafc42478ea8991f16361586a96e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00076.html#gaba31aafc42478ea8991f16361586a96e">sr_session_stopped_callback_set</a> (struct <a class="el" href="a00190.html">sr_session</a> *session, <a class="el" href="a00053.html#a5a47dcc64d187d380133c1986fce7bfd">sr_session_stopped_callback</a> cb, void *cb_data)</td></tr>
<tr class="memdesc:gaba31aafc42478ea8991f16361586a96e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the callback to be invoked after a session stopped running.  <a href="a00076.html#gaba31aafc42478ea8991f16361586a96e">More...</a><br /></td></tr>
<tr class="separator:gaba31aafc42478ea8991f16361586a96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf484c0abf0aed79a5de4dfb985246680"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00076.html#gaf484c0abf0aed79a5de4dfb985246680">sr_packet_copy</a> (const struct <a class="el" href="a00122.html">sr_datafeed_packet</a> *packet, struct <a class="el" href="a00122.html">sr_datafeed_packet</a> **copy)</td></tr>
<tr class="separator:gaf484c0abf0aed79a5de4dfb985246680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacefe885be96f97d263ccd2b44ddac7bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00076.html#gacefe885be96f97d263ccd2b44ddac7bc">sr_packet_free</a> (struct <a class="el" href="a00122.html">sr_datafeed_packet</a> *packet)</td></tr>
<tr class="separator:gacefe885be96f97d263ccd2b44ddac7bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8741998692209adfd4e352e56a57b114"><td class="memItemLeft" align="right" valign="top">const struct sr_input_module **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00080.html#ga8741998692209adfd4e352e56a57b114">sr_input_list</a> (void)</td></tr>
<tr class="memdesc:ga8741998692209adfd4e352e56a57b114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a NULL-terminated list of all available input modules.  <a href="a00080.html#ga8741998692209adfd4e352e56a57b114">More...</a><br /></td></tr>
<tr class="separator:ga8741998692209adfd4e352e56a57b114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga072925b562704cb510449f2fee55f899"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00080.html#ga072925b562704cb510449f2fee55f899">sr_input_id_get</a> (const struct sr_input_module *imod)</td></tr>
<tr class="memdesc:ga072925b562704cb510449f2fee55f899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the specified input module's ID.  <a href="a00080.html#ga072925b562704cb510449f2fee55f899">More...</a><br /></td></tr>
<tr class="separator:ga072925b562704cb510449f2fee55f899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d106248a419623aa9a1fd5e37b2e8c5"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00080.html#ga3d106248a419623aa9a1fd5e37b2e8c5">sr_input_name_get</a> (const struct sr_input_module *imod)</td></tr>
<tr class="memdesc:ga3d106248a419623aa9a1fd5e37b2e8c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the specified input module's name.  <a href="a00080.html#ga3d106248a419623aa9a1fd5e37b2e8c5">More...</a><br /></td></tr>
<tr class="separator:ga3d106248a419623aa9a1fd5e37b2e8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga622935496493c2023a4563345a4c5c24"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00080.html#ga622935496493c2023a4563345a4c5c24">sr_input_description_get</a> (const struct sr_input_module *imod)</td></tr>
<tr class="memdesc:ga622935496493c2023a4563345a4c5c24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the specified input module's description.  <a href="a00080.html#ga622935496493c2023a4563345a4c5c24">More...</a><br /></td></tr>
<tr class="separator:ga622935496493c2023a4563345a4c5c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd755e2266d3c19536add2bda2cdb2cc"><td class="memItemLeft" align="right" valign="top">const char *const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00080.html#gadd755e2266d3c19536add2bda2cdb2cc">sr_input_extensions_get</a> (const struct sr_input_module *imod)</td></tr>
<tr class="memdesc:gadd755e2266d3c19536add2bda2cdb2cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the specified input module's file extensions typical for the file format, as a NULL terminated array, or returns a NULL pointer if there is no preferred extension.  <a href="a00080.html#gadd755e2266d3c19536add2bda2cdb2cc">More...</a><br /></td></tr>
<tr class="separator:gadd755e2266d3c19536add2bda2cdb2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab57b823af6c177edf93dab2d96299f8d"><td class="memItemLeft" align="right" valign="top">const struct sr_input_module *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00080.html#gab57b823af6c177edf93dab2d96299f8d">sr_input_find</a> (char *id)</td></tr>
<tr class="memdesc:gab57b823af6c177edf93dab2d96299f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the input module with the specified ID, or NULL if no module with that id is found.  <a href="a00080.html#gab57b823af6c177edf93dab2d96299f8d">More...</a><br /></td></tr>
<tr class="separator:gab57b823af6c177edf93dab2d96299f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga947b91ce69fc64cef5b4e72b3ddf4c5b"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="a00154.html">sr_option</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00080.html#ga947b91ce69fc64cef5b4e72b3ddf4c5b">sr_input_options_get</a> (const struct sr_input_module *imod)</td></tr>
<tr class="memdesc:ga947b91ce69fc64cef5b4e72b3ddf4c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a NULL-terminated array of struct <a class="el" href="a00154.html" title="Generic option struct used by various subsystems.">sr_option</a>, or NULL if the module takes no options.  <a href="a00080.html#ga947b91ce69fc64cef5b4e72b3ddf4c5b">More...</a><br /></td></tr>
<tr class="separator:ga947b91ce69fc64cef5b4e72b3ddf4c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7bccebee91a6991a65018a68b68c264"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00080.html#gae7bccebee91a6991a65018a68b68c264">sr_input_options_free</a> (const struct <a class="el" href="a00154.html">sr_option</a> **options)</td></tr>
<tr class="memdesc:gae7bccebee91a6991a65018a68b68c264"><td class="mdescLeft">&#160;</td><td class="mdescRight">After a call to <a class="el" href="a00080.html#ga947b91ce69fc64cef5b4e72b3ddf4c5b" title="Returns a NULL-terminated array of struct sr_option, or NULL if the module takes no options.">sr_input_options_get()</a>, this function cleans up all resources returned by that call.  <a href="a00080.html#gae7bccebee91a6991a65018a68b68c264">More...</a><br /></td></tr>
<tr class="separator:gae7bccebee91a6991a65018a68b68c264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga555801748623b935b60be3e662f9ea36"><td class="memItemLeft" align="right" valign="top">struct sr_input *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00080.html#ga555801748623b935b60be3e662f9ea36">sr_input_new</a> (const struct sr_input_module *imod, GHashTable *options)</td></tr>
<tr class="memdesc:ga555801748623b935b60be3e662f9ea36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new input instance using the specified input module.  <a href="a00080.html#ga555801748623b935b60be3e662f9ea36">More...</a><br /></td></tr>
<tr class="separator:ga555801748623b935b60be3e662f9ea36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d226bd14eb70973129c736e24ec905a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00080.html#ga3d226bd14eb70973129c736e24ec905a">sr_input_scan_buffer</a> (GString *buf, const struct sr_input **in)</td></tr>
<tr class="memdesc:ga3d226bd14eb70973129c736e24ec905a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to find an input module that can parse the given buffer.  <a href="a00080.html#ga3d226bd14eb70973129c736e24ec905a">More...</a><br /></td></tr>
<tr class="separator:ga3d226bd14eb70973129c736e24ec905a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57905453bc7b85d23e80862afb75e4d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00080.html#ga57905453bc7b85d23e80862afb75e4d4">sr_input_scan_file</a> (const char *filename, const struct sr_input **in)</td></tr>
<tr class="memdesc:ga57905453bc7b85d23e80862afb75e4d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to find an input module that can parse the given file.  <a href="a00080.html#ga57905453bc7b85d23e80862afb75e4d4">More...</a><br /></td></tr>
<tr class="separator:ga57905453bc7b85d23e80862afb75e4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga267353360cd2dfd9d4783a192de2ee09"><td class="memItemLeft" align="right" valign="top">const struct sr_input_module *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00080.html#ga267353360cd2dfd9d4783a192de2ee09">sr_input_module_get</a> (const struct sr_input *in)</td></tr>
<tr class="memdesc:ga267353360cd2dfd9d4783a192de2ee09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the input instance's module "class".  <a href="a00080.html#ga267353360cd2dfd9d4783a192de2ee09">More...</a><br /></td></tr>
<tr class="separator:ga267353360cd2dfd9d4783a192de2ee09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6021700cdb73e4c843c16f88f75beed"><td class="memItemLeft" align="right" valign="top">struct sr_dev_inst *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00080.html#gad6021700cdb73e4c843c16f88f75beed">sr_input_dev_inst_get</a> (const struct sr_input *in)</td></tr>
<tr class="memdesc:gad6021700cdb73e4c843c16f88f75beed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the input instance's (virtual) device instance.  <a href="a00080.html#gad6021700cdb73e4c843c16f88f75beed">More...</a><br /></td></tr>
<tr class="separator:gad6021700cdb73e4c843c16f88f75beed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada8138722494a8b7665749f5b3297805"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00080.html#gada8138722494a8b7665749f5b3297805">sr_input_send</a> (const struct sr_input *in, GString *buf)</td></tr>
<tr class="memdesc:gada8138722494a8b7665749f5b3297805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data to the specified input instance.  <a href="a00080.html#gada8138722494a8b7665749f5b3297805">More...</a><br /></td></tr>
<tr class="separator:gada8138722494a8b7665749f5b3297805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa887145d0ff9ce8aea3b9d9c4b5c0ea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00080.html#gaaa887145d0ff9ce8aea3b9d9c4b5c0ea">sr_input_end</a> (const struct sr_input *in)</td></tr>
<tr class="memdesc:gaaa887145d0ff9ce8aea3b9d9c4b5c0ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal the input module no more data will come.  <a href="a00080.html#gaaa887145d0ff9ce8aea3b9d9c4b5c0ea">More...</a><br /></td></tr>
<tr class="separator:gaaa887145d0ff9ce8aea3b9d9c4b5c0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedab9768c2587f4f14e456c25f55193d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00080.html#gaedab9768c2587f4f14e456c25f55193d">sr_input_reset</a> (const struct sr_input *in)</td></tr>
<tr class="memdesc:gaedab9768c2587f4f14e456c25f55193d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the input module's input handling structures.  <a href="a00080.html#gaedab9768c2587f4f14e456c25f55193d">More...</a><br /></td></tr>
<tr class="separator:gaedab9768c2587f4f14e456c25f55193d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1d7eb09c7366fe32cc90191d08292eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00080.html#gaa1d7eb09c7366fe32cc90191d08292eb">sr_input_free</a> (const struct sr_input *in)</td></tr>
<tr class="memdesc:gaa1d7eb09c7366fe32cc90191d08292eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the specified input instance and all associated resources.  <a href="a00080.html#gaa1d7eb09c7366fe32cc90191d08292eb">More...</a><br /></td></tr>
<tr class="separator:gaa1d7eb09c7366fe32cc90191d08292eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef157a70847b5cd4e5db3f706f97bb7a"><td class="memItemLeft" align="right" valign="top">const struct sr_output_module **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00081.html#gaef157a70847b5cd4e5db3f706f97bb7a">sr_output_list</a> (void)</td></tr>
<tr class="memdesc:gaef157a70847b5cd4e5db3f706f97bb7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a NULL-terminated list of all available output modules.  <a href="a00081.html#gaef157a70847b5cd4e5db3f706f97bb7a">More...</a><br /></td></tr>
<tr class="separator:gaef157a70847b5cd4e5db3f706f97bb7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadaaeaa73ee938484c31094a05fc5cea6"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00081.html#gadaaeaa73ee938484c31094a05fc5cea6">sr_output_id_get</a> (const struct sr_output_module *omod)</td></tr>
<tr class="memdesc:gadaaeaa73ee938484c31094a05fc5cea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the specified output module's ID.  <a href="a00081.html#gadaaeaa73ee938484c31094a05fc5cea6">More...</a><br /></td></tr>
<tr class="separator:gadaaeaa73ee938484c31094a05fc5cea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1764b518bd10533a686b3a50a849aed"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00081.html#gaf1764b518bd10533a686b3a50a849aed">sr_output_name_get</a> (const struct sr_output_module *omod)</td></tr>
<tr class="memdesc:gaf1764b518bd10533a686b3a50a849aed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the specified output module's name.  <a href="a00081.html#gaf1764b518bd10533a686b3a50a849aed">More...</a><br /></td></tr>
<tr class="separator:gaf1764b518bd10533a686b3a50a849aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6538c0a75f51cba0c704cca50d2d401"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00081.html#gaf6538c0a75f51cba0c704cca50d2d401">sr_output_description_get</a> (const struct sr_output_module *omod)</td></tr>
<tr class="memdesc:gaf6538c0a75f51cba0c704cca50d2d401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the specified output module's description.  <a href="a00081.html#gaf6538c0a75f51cba0c704cca50d2d401">More...</a><br /></td></tr>
<tr class="separator:gaf6538c0a75f51cba0c704cca50d2d401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1b775eab6f493462ad96d83cb5eb950"><td class="memItemLeft" align="right" valign="top">const char *const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00081.html#gab1b775eab6f493462ad96d83cb5eb950">sr_output_extensions_get</a> (const struct sr_output_module *omod)</td></tr>
<tr class="memdesc:gab1b775eab6f493462ad96d83cb5eb950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the specified output module's file extensions typical for the file format, as a NULL terminated array, or returns a NULL pointer if there is no preferred extension.  <a href="a00081.html#gab1b775eab6f493462ad96d83cb5eb950">More...</a><br /></td></tr>
<tr class="separator:gab1b775eab6f493462ad96d83cb5eb950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ebad67fb70ac52f736d21190637a128"><td class="memItemLeft" align="right" valign="top">const struct sr_output_module *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00081.html#ga4ebad67fb70ac52f736d21190637a128">sr_output_find</a> (char *id)</td></tr>
<tr class="memdesc:ga4ebad67fb70ac52f736d21190637a128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the output module with the specified ID, or NULL if no module with that id is found.  <a href="a00081.html#ga4ebad67fb70ac52f736d21190637a128">More...</a><br /></td></tr>
<tr class="separator:ga4ebad67fb70ac52f736d21190637a128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafc116fd45e035ab626da3a155a34125"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="a00154.html">sr_option</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00081.html#gaafc116fd45e035ab626da3a155a34125">sr_output_options_get</a> (const struct sr_output_module *omod)</td></tr>
<tr class="memdesc:gaafc116fd45e035ab626da3a155a34125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a NULL-terminated array of struct <a class="el" href="a00154.html" title="Generic option struct used by various subsystems.">sr_option</a>, or NULL if the module takes no options.  <a href="a00081.html#gaafc116fd45e035ab626da3a155a34125">More...</a><br /></td></tr>
<tr class="separator:gaafc116fd45e035ab626da3a155a34125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a8ecfb107a90d4d9fad92bf80b650cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00081.html#ga5a8ecfb107a90d4d9fad92bf80b650cc">sr_output_options_free</a> (const struct <a class="el" href="a00154.html">sr_option</a> **opts)</td></tr>
<tr class="memdesc:ga5a8ecfb107a90d4d9fad92bf80b650cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">After a call to <a class="el" href="a00081.html#gaafc116fd45e035ab626da3a155a34125" title="Returns a NULL-terminated array of struct sr_option, or NULL if the module takes no options.">sr_output_options_get()</a>, this function cleans up all resources returned by that call.  <a href="a00081.html#ga5a8ecfb107a90d4d9fad92bf80b650cc">More...</a><br /></td></tr>
<tr class="separator:ga5a8ecfb107a90d4d9fad92bf80b650cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3d851b86178014ba38725c882df310c"><td class="memItemLeft" align="right" valign="top">const struct sr_output *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00081.html#gac3d851b86178014ba38725c882df310c">sr_output_new</a> (const struct sr_output_module *omod, GHashTable *params, const struct sr_dev_inst *sdi, const char *filename)</td></tr>
<tr class="memdesc:gac3d851b86178014ba38725c882df310c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new output instance using the specified output module.  <a href="a00081.html#gac3d851b86178014ba38725c882df310c">More...</a><br /></td></tr>
<tr class="separator:gac3d851b86178014ba38725c882df310c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ebef60903110bb03be4c3e3783ac9b9"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00081.html#ga6ebef60903110bb03be4c3e3783ac9b9">sr_output_test_flag</a> (const struct sr_output_module *omod, uint64_t flag)</td></tr>
<tr class="separator:ga6ebef60903110bb03be4c3e3783ac9b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb03f8a92c738c52b37d019fc893aeac"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00081.html#gacb03f8a92c738c52b37d019fc893aeac">sr_output_send</a> (const struct sr_output *o, const struct <a class="el" href="a00122.html">sr_datafeed_packet</a> *packet, GString **out)</td></tr>
<tr class="memdesc:gacb03f8a92c738c52b37d019fc893aeac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a packet to the specified output instance.  <a href="a00081.html#gacb03f8a92c738c52b37d019fc893aeac">More...</a><br /></td></tr>
<tr class="separator:gacb03f8a92c738c52b37d019fc893aeac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45328449dcc9cb8804c2635ebf558182"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00081.html#ga45328449dcc9cb8804c2635ebf558182">sr_output_free</a> (const struct sr_output *o)</td></tr>
<tr class="memdesc:ga45328449dcc9cb8804c2635ebf558182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the specified output instance and all associated resources.  <a href="a00081.html#ga45328449dcc9cb8804c2635ebf558182">More...</a><br /></td></tr>
<tr class="separator:ga45328449dcc9cb8804c2635ebf558182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d6573f5a163c1c5dde57408d4149e5e"><td class="memItemLeft" align="right" valign="top">const struct sr_transform_module **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00082.html#ga3d6573f5a163c1c5dde57408d4149e5e">sr_transform_list</a> (void)</td></tr>
<tr class="memdesc:ga3d6573f5a163c1c5dde57408d4149e5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a NULL-terminated list of all available transform modules.  <a href="a00082.html#ga3d6573f5a163c1c5dde57408d4149e5e">More...</a><br /></td></tr>
<tr class="separator:ga3d6573f5a163c1c5dde57408d4149e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19a02c79476c3b4d08946fe9ca1d2a6b"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00082.html#ga19a02c79476c3b4d08946fe9ca1d2a6b">sr_transform_id_get</a> (const struct sr_transform_module *tmod)</td></tr>
<tr class="memdesc:ga19a02c79476c3b4d08946fe9ca1d2a6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the specified transform module's ID.  <a href="a00082.html#ga19a02c79476c3b4d08946fe9ca1d2a6b">More...</a><br /></td></tr>
<tr class="separator:ga19a02c79476c3b4d08946fe9ca1d2a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43638b933fdb0cff24e9b4c3ae60fa06"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00082.html#ga43638b933fdb0cff24e9b4c3ae60fa06">sr_transform_name_get</a> (const struct sr_transform_module *tmod)</td></tr>
<tr class="memdesc:ga43638b933fdb0cff24e9b4c3ae60fa06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the specified transform module's name.  <a href="a00082.html#ga43638b933fdb0cff24e9b4c3ae60fa06">More...</a><br /></td></tr>
<tr class="separator:ga43638b933fdb0cff24e9b4c3ae60fa06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga213ab97732cb4a1aee5f18df17c60434"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00082.html#ga213ab97732cb4a1aee5f18df17c60434">sr_transform_description_get</a> (const struct sr_transform_module *tmod)</td></tr>
<tr class="memdesc:ga213ab97732cb4a1aee5f18df17c60434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the specified transform module's description.  <a href="a00082.html#ga213ab97732cb4a1aee5f18df17c60434">More...</a><br /></td></tr>
<tr class="separator:ga213ab97732cb4a1aee5f18df17c60434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e58f96b92dd90fef598491c418a4e33"><td class="memItemLeft" align="right" valign="top">const struct sr_transform_module *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00082.html#ga0e58f96b92dd90fef598491c418a4e33">sr_transform_find</a> (const char *id)</td></tr>
<tr class="memdesc:ga0e58f96b92dd90fef598491c418a4e33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the transform module with the specified ID, or NULL if no module with that ID is found.  <a href="a00082.html#ga0e58f96b92dd90fef598491c418a4e33">More...</a><br /></td></tr>
<tr class="separator:ga0e58f96b92dd90fef598491c418a4e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7333904e22a5229921e2e2517a7046c0"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="a00154.html">sr_option</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00082.html#ga7333904e22a5229921e2e2517a7046c0">sr_transform_options_get</a> (const struct sr_transform_module *tmod)</td></tr>
<tr class="memdesc:ga7333904e22a5229921e2e2517a7046c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a NULL-terminated array of struct <a class="el" href="a00154.html" title="Generic option struct used by various subsystems.">sr_option</a>, or NULL if the module takes no options.  <a href="a00082.html#ga7333904e22a5229921e2e2517a7046c0">More...</a><br /></td></tr>
<tr class="separator:ga7333904e22a5229921e2e2517a7046c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14e80f34546c57130e9af030fae2b077"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00082.html#ga14e80f34546c57130e9af030fae2b077">sr_transform_options_free</a> (const struct <a class="el" href="a00154.html">sr_option</a> **opts)</td></tr>
<tr class="memdesc:ga14e80f34546c57130e9af030fae2b077"><td class="mdescLeft">&#160;</td><td class="mdescRight">After a call to <a class="el" href="a00082.html#ga7333904e22a5229921e2e2517a7046c0" title="Returns a NULL-terminated array of struct sr_option, or NULL if the module takes no options.">sr_transform_options_get()</a>, this function cleans up all resources returned by that call.  <a href="a00082.html#ga14e80f34546c57130e9af030fae2b077">More...</a><br /></td></tr>
<tr class="separator:ga14e80f34546c57130e9af030fae2b077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3e048363e44899d058e7ca1a62f942a"><td class="memItemLeft" align="right" valign="top">const struct sr_transform *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00082.html#gad3e048363e44899d058e7ca1a62f942a">sr_transform_new</a> (const struct sr_transform_module *tmod, GHashTable *params, const struct sr_dev_inst *sdi)</td></tr>
<tr class="memdesc:gad3e048363e44899d058e7ca1a62f942a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new transform instance using the specified transform module.  <a href="a00082.html#gad3e048363e44899d058e7ca1a62f942a">More...</a><br /></td></tr>
<tr class="separator:gad3e048363e44899d058e7ca1a62f942a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac86732ac317991b2b859fde11f5bf9eb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00082.html#gac86732ac317991b2b859fde11f5bf9eb">sr_transform_free</a> (const struct sr_transform *t)</td></tr>
<tr class="memdesc:gac86732ac317991b2b859fde11f5bf9eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the specified transform instance and all associated resources.  <a href="a00082.html#gac86732ac317991b2b859fde11f5bf9eb">More...</a><br /></td></tr>
<tr class="separator:gac86732ac317991b2b859fde11f5bf9eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0276d66ef0c3ced910af1c7799c57895"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="a00106.html">sr_trigger</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00078.html#ga0276d66ef0c3ced910af1c7799c57895">sr_trigger_new</a> (const char *name)</td></tr>
<tr class="memdesc:ga0276d66ef0c3ced910af1c7799c57895"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new trigger.  <a href="a00078.html#ga0276d66ef0c3ced910af1c7799c57895">More...</a><br /></td></tr>
<tr class="separator:ga0276d66ef0c3ced910af1c7799c57895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39e4c8e299f0d246cb36914c8e9d6e7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00078.html#ga39e4c8e299f0d246cb36914c8e9d6e7c">sr_trigger_free</a> (struct <a class="el" href="a00106.html">sr_trigger</a> *trig)</td></tr>
<tr class="memdesc:ga39e4c8e299f0d246cb36914c8e9d6e7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a previously allocated trigger.  <a href="a00078.html#ga39e4c8e299f0d246cb36914c8e9d6e7c">More...</a><br /></td></tr>
<tr class="separator:ga39e4c8e299f0d246cb36914c8e9d6e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga225a5c7467d13ac60798ffd1fbb3750d"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="a00110.html">sr_trigger_stage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00078.html#ga225a5c7467d13ac60798ffd1fbb3750d">sr_trigger_stage_add</a> (struct <a class="el" href="a00106.html">sr_trigger</a> *trig)</td></tr>
<tr class="memdesc:ga225a5c7467d13ac60798ffd1fbb3750d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new trigger stage and add it to the specified trigger.  <a href="a00078.html#ga225a5c7467d13ac60798ffd1fbb3750d">More...</a><br /></td></tr>
<tr class="separator:ga225a5c7467d13ac60798ffd1fbb3750d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55eeefded4138be23a6989ead396174a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00078.html#ga55eeefded4138be23a6989ead396174a">sr_trigger_match_add</a> (struct <a class="el" href="a00110.html">sr_trigger_stage</a> *stage, struct <a class="el" href="a00162.html">sr_channel</a> *ch, int trigger_match, float value)</td></tr>
<tr class="memdesc:ga55eeefded4138be23a6989ead396174a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new trigger match and add it to the specified trigger stage.  <a href="a00078.html#ga55eeefded4138be23a6989ead396174a">More...</a><br /></td></tr>
<tr class="separator:ga55eeefded4138be23a6989ead396174a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa663dbbaa19113a8799256024df1dc2c"><td class="memItemLeft" align="right" valign="top">GSList *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00075.html#gaa663dbbaa19113a8799256024df1dc2c">sr_serial_list</a> (const struct <a class="el" href="a00178.html">sr_dev_driver</a> *driver)</td></tr>
<tr class="memdesc:gaa663dbbaa19113a8799256024df1dc2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">List available serial devices.  <a href="a00075.html#gaa663dbbaa19113a8799256024df1dc2c">More...</a><br /></td></tr>
<tr class="separator:gaa663dbbaa19113a8799256024df1dc2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c53acd13d3ff7895d4bc9d1f1fc3df8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00075.html#ga1c53acd13d3ff7895d4bc9d1f1fc3df8">sr_serial_free</a> (struct <a class="el" href="a00182.html">sr_serial_port</a> *serial)</td></tr>
<tr class="memdesc:ga1c53acd13d3ff7895d4bc9d1f1fc3df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a previously allocated <a class="el" href="a00182.html" title="Serial port descriptor.">sr_serial_port</a> structure.  <a href="a00075.html#ga1c53acd13d3ff7895d4bc9d1f1fc3df8">More...</a><br /></td></tr>
<tr class="separator:ga1c53acd13d3ff7895d4bc9d1f1fc3df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0598bee8e091c1cfdf442d160c70e4e9"><td class="memItemLeft" align="right" valign="top">GSList *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00053.html#a0598bee8e091c1cfdf442d160c70e4e9">sr_resourcepaths_get</a> (int res_type)</td></tr>
<tr class="memdesc:a0598bee8e091c1cfdf442d160c70e4e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of paths where we look for resource (e.g.  <a href="a00053.html#a0598bee8e091c1cfdf442d160c70e4e9">More...</a><br /></td></tr>
<tr class="separator:a0598bee8e091c1cfdf442d160c70e4e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6485cd6a98a0b05dec092b6b2a66e8a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00053.html#af6485cd6a98a0b05dec092b6b2a66e8a">sr_resource_set_hooks</a> (struct <a class="el" href="a00186.html">sr_context</a> *ctx, <a class="el" href="a00053.html#a752a7d3375e2685e90893b1089d63972">sr_resource_open_callback</a> open_cb, <a class="el" href="a00053.html#a51a8a2ac69656aabe68b54dab38288af">sr_resource_close_callback</a> close_cb, <a class="el" href="a00053.html#aa98b4fba926e47164a1701658efe2550">sr_resource_read_callback</a> read_cb, void *cb_data)</td></tr>
<tr class="memdesc:af6485cd6a98a0b05dec092b6b2a66e8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install resource access hooks.  <a href="a00053.html#af6485cd6a98a0b05dec092b6b2a66e8a">More...</a><br /></td></tr>
<tr class="separator:af6485cd6a98a0b05dec092b6b2a66e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7126aced4c86bf82f91b4fb0a2713e68"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00077.html#ga7126aced4c86bf82f91b4fb0a2713e68">sr_si_string_u64</a> (uint64_t x, const char *unit)</td></tr>
<tr class="memdesc:ga7126aced4c86bf82f91b4fb0a2713e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a numeric value value to its "natural" string representation in SI units.  <a href="a00077.html#ga7126aced4c86bf82f91b4fb0a2713e68">More...</a><br /></td></tr>
<tr class="separator:ga7126aced4c86bf82f91b4fb0a2713e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4e6df219e62795b510a932f567598ad"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00077.html#gab4e6df219e62795b510a932f567598ad">sr_samplerate_string</a> (uint64_t samplerate)</td></tr>
<tr class="memdesc:gab4e6df219e62795b510a932f567598ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a numeric samplerate value to its "natural" string representation.  <a href="a00077.html#gab4e6df219e62795b510a932f567598ad">More...</a><br /></td></tr>
<tr class="separator:gab4e6df219e62795b510a932f567598ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bee5618e4ddfa4bd90e3fc46c5ad8f1"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00077.html#ga3bee5618e4ddfa4bd90e3fc46c5ad8f1">sr_period_string</a> (uint64_t v_p, uint64_t v_q)</td></tr>
<tr class="memdesc:ga3bee5618e4ddfa4bd90e3fc46c5ad8f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a numeric period value to the "natural" string representation of its period value.  <a href="a00077.html#ga3bee5618e4ddfa4bd90e3fc46c5ad8f1">More...</a><br /></td></tr>
<tr class="separator:ga3bee5618e4ddfa4bd90e3fc46c5ad8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga547339234122efc4e3162d4a514a6216"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00077.html#ga547339234122efc4e3162d4a514a6216">sr_voltage_string</a> (uint64_t v_p, uint64_t v_q)</td></tr>
<tr class="memdesc:ga547339234122efc4e3162d4a514a6216"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a numeric voltage value to the "natural" string representation of its voltage value.  <a href="a00077.html#ga547339234122efc4e3162d4a514a6216">More...</a><br /></td></tr>
<tr class="separator:ga547339234122efc4e3162d4a514a6216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadc9a8f474d285002395ce5e34ae2ee2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00077.html#gaadc9a8f474d285002395ce5e34ae2ee2">sr_parse_sizestring</a> (const char *sizestring, uint64_t *size)</td></tr>
<tr class="memdesc:gaadc9a8f474d285002395ce5e34ae2ee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a "natural" string representation of a size value to uint64_t.  <a href="a00077.html#gaadc9a8f474d285002395ce5e34ae2ee2">More...</a><br /></td></tr>
<tr class="separator:gaadc9a8f474d285002395ce5e34ae2ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32b3f8287c1be88d88273d5e233b8d8a"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00077.html#ga32b3f8287c1be88d88273d5e233b8d8a">sr_parse_timestring</a> (const char *timestring)</td></tr>
<tr class="memdesc:ga32b3f8287c1be88d88273d5e233b8d8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a "natural" string representation of a time value to an uint64_t value in milliseconds.  <a href="a00077.html#ga32b3f8287c1be88d88273d5e233b8d8a">More...</a><br /></td></tr>
<tr class="separator:ga32b3f8287c1be88d88273d5e233b8d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5de1c92b1a833f4a9d31b8bbd02df2e"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00077.html#gac5de1c92b1a833f4a9d31b8bbd02df2e">sr_parse_boolstring</a> (const char *boolstring)</td></tr>
<tr class="separator:gac5de1c92b1a833f4a9d31b8bbd02df2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafba460c1d435fe35501ac0e8a4ec4283"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00077.html#gafba460c1d435fe35501ac0e8a4ec4283">sr_parse_period</a> (const char *periodstr, uint64_t *p, uint64_t *q)</td></tr>
<tr class="separator:gafba460c1d435fe35501ac0e8a4ec4283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4dd6b1a65ca06339639a9a0933dc7d9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00077.html#gad4dd6b1a65ca06339639a9a0933dc7d9">sr_parse_voltage</a> (const char *voltstr, uint64_t *p, uint64_t *q)</td></tr>
<tr class="separator:gad4dd6b1a65ca06339639a9a0933dc7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99e7a0edbcad0e8f48b402aaab07b135"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00077.html#ga99e7a0edbcad0e8f48b402aaab07b135">sr_sprintf_ascii</a> (char *buf, const char *format,...)</td></tr>
<tr class="memdesc:ga99e7a0edbcad0e8f48b402aaab07b135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compose a string with a format string in the buffer pointed to by buf.  <a href="a00077.html#ga99e7a0edbcad0e8f48b402aaab07b135">More...</a><br /></td></tr>
<tr class="separator:ga99e7a0edbcad0e8f48b402aaab07b135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc3b0e400d218f8f3ffbef7867b96dc3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00077.html#gadc3b0e400d218f8f3ffbef7867b96dc3">sr_vsprintf_ascii</a> (char *buf, const char *format, va_list args)</td></tr>
<tr class="memdesc:gadc3b0e400d218f8f3ffbef7867b96dc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compose a string with a format string in the buffer pointed to by buf.  <a href="a00077.html#gadc3b0e400d218f8f3ffbef7867b96dc3">More...</a><br /></td></tr>
<tr class="separator:gadc3b0e400d218f8f3ffbef7867b96dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad79390f49111f423ba58d98f539b10c9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00077.html#gad79390f49111f423ba58d98f539b10c9">sr_snprintf_ascii</a> (char *buf, size_t buf_size, const char *format,...)</td></tr>
<tr class="memdesc:gad79390f49111f423ba58d98f539b10c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes a string with a format string (like printf) in the buffer pointed by buf (taking buf_size as the maximum buffer capacity to fill).  <a href="a00077.html#gad79390f49111f423ba58d98f539b10c9">More...</a><br /></td></tr>
<tr class="separator:gad79390f49111f423ba58d98f539b10c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3021c6a73fddd6a4ce43ad8058d231cc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00077.html#ga3021c6a73fddd6a4ce43ad8058d231cc">sr_vsnprintf_ascii</a> (char *buf, size_t buf_size, const char *format, va_list args)</td></tr>
<tr class="memdesc:ga3021c6a73fddd6a4ce43ad8058d231cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes a string with a format string (like printf) in the buffer pointed by buf (taking buf_size as the maximum buffer capacity to fill).  <a href="a00077.html#ga3021c6a73fddd6a4ce43ad8058d231cc">More...</a><br /></td></tr>
<tr class="separator:ga3021c6a73fddd6a4ce43ad8058d231cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fb4eb4552fd16a31f0aadffcad8d096"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00077.html#ga5fb4eb4552fd16a31f0aadffcad8d096">sr_parse_rational</a> (const char *str, struct <a class="el" href="a00118.html">sr_rational</a> *ret)</td></tr>
<tr class="memdesc:ga5fb4eb4552fd16a31f0aadffcad8d096"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string representation of a numeric value to a <a class="el" href="a00118.html">sr_rational</a>.  <a href="a00077.html#ga5fb4eb4552fd16a31f0aadffcad8d096">More...</a><br /></td></tr>
<tr class="separator:ga5fb4eb4552fd16a31f0aadffcad8d096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa578d2cf576270655de7bdc3d84031a1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00079.html#gaa578d2cf576270655de7bdc3d84031a1">sr_package_version_major_get</a> (void)</td></tr>
<tr class="memdesc:gaa578d2cf576270655de7bdc3d84031a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the major libsigrok package version number.  <a href="a00079.html#gaa578d2cf576270655de7bdc3d84031a1">More...</a><br /></td></tr>
<tr class="separator:gaa578d2cf576270655de7bdc3d84031a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8655c30cfab2f1be18cf10dad181d057"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00079.html#ga8655c30cfab2f1be18cf10dad181d057">sr_package_version_minor_get</a> (void)</td></tr>
<tr class="memdesc:ga8655c30cfab2f1be18cf10dad181d057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minor libsigrok package version number.  <a href="a00079.html#ga8655c30cfab2f1be18cf10dad181d057">More...</a><br /></td></tr>
<tr class="separator:ga8655c30cfab2f1be18cf10dad181d057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f79f39844f62898869bcae94e8eb60c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00079.html#ga1f79f39844f62898869bcae94e8eb60c">sr_package_version_micro_get</a> (void)</td></tr>
<tr class="memdesc:ga1f79f39844f62898869bcae94e8eb60c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the micro libsigrok package version number.  <a href="a00079.html#ga1f79f39844f62898869bcae94e8eb60c">More...</a><br /></td></tr>
<tr class="separator:ga1f79f39844f62898869bcae94e8eb60c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab69dee3c84c594faf1b7a20587ebec5d"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00079.html#gab69dee3c84c594faf1b7a20587ebec5d">sr_package_version_string_get</a> (void)</td></tr>
<tr class="memdesc:gab69dee3c84c594faf1b7a20587ebec5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the libsigrok package version number as a string.  <a href="a00079.html#gab69dee3c84c594faf1b7a20587ebec5d">More...</a><br /></td></tr>
<tr class="separator:gab69dee3c84c594faf1b7a20587ebec5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cffad288a578de133a3859f7e4e39d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00079.html#ga5cffad288a578de133a3859f7e4e39d4">sr_lib_version_current_get</a> (void)</td></tr>
<tr class="memdesc:ga5cffad288a578de133a3859f7e4e39d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the "current" part of the libsigrok library version number.  <a href="a00079.html#ga5cffad288a578de133a3859f7e4e39d4">More...</a><br /></td></tr>
<tr class="separator:ga5cffad288a578de133a3859f7e4e39d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d128fd0fff141ef16bcddd3cf1e6fe9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00079.html#ga2d128fd0fff141ef16bcddd3cf1e6fe9">sr_lib_version_revision_get</a> (void)</td></tr>
<tr class="memdesc:ga2d128fd0fff141ef16bcddd3cf1e6fe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the "revision" part of the libsigrok library version number.  <a href="a00079.html#ga2d128fd0fff141ef16bcddd3cf1e6fe9">More...</a><br /></td></tr>
<tr class="separator:ga2d128fd0fff141ef16bcddd3cf1e6fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf969bd6aef6f09cf2301e26b160891df"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00079.html#gaf969bd6aef6f09cf2301e26b160891df">sr_lib_version_age_get</a> (void)</td></tr>
<tr class="memdesc:gaf969bd6aef6f09cf2301e26b160891df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the "age" part of the libsigrok library version number.  <a href="a00079.html#gaf969bd6aef6f09cf2301e26b160891df">More...</a><br /></td></tr>
<tr class="separator:gaf969bd6aef6f09cf2301e26b160891df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab62c0a995dcf873504edbd7c6f610b25"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00079.html#gab62c0a995dcf873504edbd7c6f610b25">sr_lib_version_string_get</a> (void)</td></tr>
<tr class="memdesc:gab62c0a995dcf873504edbd7c6f610b25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the libsigrok library version number as a string.  <a href="a00079.html#gab62c0a995dcf873504edbd7c6f610b25">More...</a><br /></td></tr>
<tr class="separator:gab62c0a995dcf873504edbd7c6f610b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7aacfdde4d4f0b3a64d50797f3c10103"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00072.html#ga7aacfdde4d4f0b3a64d50797f3c10103">sr_strerror</a> (int error_code)</td></tr>
<tr class="memdesc:ga7aacfdde4d4f0b3a64d50797f3c10103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a human-readable error string for the given libsigrok error code.  <a href="a00072.html#ga7aacfdde4d4f0b3a64d50797f3c10103">More...</a><br /></td></tr>
<tr class="separator:ga7aacfdde4d4f0b3a64d50797f3c10103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b17e89928756a8282c4a085762dcf37"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00072.html#ga7b17e89928756a8282c4a085762dcf37">sr_strerror_name</a> (int error_code)</td></tr>
<tr class="memdesc:ga7b17e89928756a8282c4a085762dcf37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the "name" string of the given libsigrok error code.  <a href="a00072.html#ga7b17e89928756a8282c4a085762dcf37">More...</a><br /></td></tr>
<tr class="separator:ga7b17e89928756a8282c4a085762dcf37"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Header file containing API function prototypes. </p>

<p class="definition">Definition in file <a class="el" href="a00053_source.html">proto.h</a>.</p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="abe3dfadc282fa9e0cc1479a27feec66b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe3dfadc282fa9e0cc1479a27feec66b">&#9670;&nbsp;</a></span>sr_datafeed_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* sr_datafeed_callback) (const struct sr_dev_inst *sdi, const struct <a class="el" href="a00122.html">sr_datafeed_packet</a> *packet, void *cb_data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00053_source.html#l00126">126</a> of file <a class="el" href="a00053_source.html">proto.h</a>.</p>

</div>
</div>
<a id="a89f99efa4192e3bf48461c3bf178241b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89f99efa4192e3bf48461c3bf178241b">&#9670;&nbsp;</a></span>sr_log_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* sr_log_callback) (void *cb_data, int loglevel, const char *format, va_list args)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00053_source.html#l00063">63</a> of file <a class="el" href="a00053_source.html">proto.h</a>.</p>

</div>
</div>
<a id="a51a8a2ac69656aabe68b54dab38288af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a8a2ac69656aabe68b54dab38288af">&#9670;&nbsp;</a></span>sr_resource_close_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* sr_resource_close_callback) (struct <a class="el" href="a00158.html">sr_resource</a> *res, void *cb_data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00053_source.html#l00233">233</a> of file <a class="el" href="a00053_source.html">proto.h</a>.</p>

</div>
</div>
<a id="a752a7d3375e2685e90893b1089d63972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a752a7d3375e2685e90893b1089d63972">&#9670;&nbsp;</a></span>sr_resource_open_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* sr_resource_open_callback) (struct <a class="el" href="a00158.html">sr_resource</a> *res, const char *name, void *cb_data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00053_source.html#l00231">231</a> of file <a class="el" href="a00053_source.html">proto.h</a>.</p>

</div>
</div>
<a id="aa98b4fba926e47164a1701658efe2550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa98b4fba926e47164a1701658efe2550">&#9670;&nbsp;</a></span>sr_resource_read_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef gssize(* sr_resource_read_callback) (const struct <a class="el" href="a00158.html">sr_resource</a> *res, void *buf, size_t count, void *cb_data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00053_source.html#l00235">235</a> of file <a class="el" href="a00053_source.html">proto.h</a>.</p>

</div>
</div>
<a id="a5a47dcc64d187d380133c1986fce7bfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a47dcc64d187d380133c1986fce7bfd">&#9670;&nbsp;</a></span>sr_session_stopped_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* sr_session_stopped_callback) (void *data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00053_source.html#l00125">125</a> of file <a class="el" href="a00053_source.html">proto.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="abae077d85c8390eff878bf7d096d929a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abae077d85c8390eff878bf7d096d929a">&#9670;&nbsp;</a></span>sr_a2l_schmitt_trigger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sr_a2l_schmitt_trigger </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="a00138.html">sr_datafeed_analog</a> *&#160;</td>
          <td class="paramname"><em>analog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>lo_thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>hi_thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert analog values to logic values by using a Schmitt-trigger algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">analog</td><td>The analog input values. </td></tr>
    <tr><td class="paramname">lo_thr</td><td>The low threshold - result becomes 0 below it. </td></tr>
    <tr><td class="paramname">hi_thr</td><td>The high threshold - result becomes 1 above it. </td></tr>
    <tr><td class="paramname">state</td><td>The internal converter state. Must contain the state of logic sample n-1, will contain the state of logic sample n+count upon exit. </td></tr>
    <tr><td class="paramname">output</td><td>The converted output values; either 0 or 1. Must provide space for count bytes. </td></tr>
    <tr><td class="paramname">count</td><td>The number of samples to process.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SR_OK on success or SR_ERR on failure. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00011_source.html#l00081">81</a> of file <a class="el" href="a00011_source.html">conversion.c</a>.</p>

<p class="reference">References <a class="el" href="a00050_source.html#l00518">sr_datafeed_analog::data</a>, <a class="el" href="a00050_source.html#l00520">sr_datafeed_analog::encoding</a>, <a class="el" href="a00050_source.html#l00528">sr_analog_encoding::is_float</a>, <a class="el" href="a00002_source.html#l00177">sr_analog_to_float()</a>, <a class="el" href="a00050_source.html#l00068">SR_ERR</a>, and <a class="el" href="a00050_source.html#l00067">SR_OK</a>.</p>
<div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><img src="a00053_abae077d85c8390eff878bf7d096d929a_cgraph.png" border="0" usemap="#aa00053_abae077d85c8390eff878bf7d096d929a_cgraph" alt=""/></div>
<map name="aa00053_abae077d85c8390eff878bf7d096d929a_cgraph" id="aa00053_abae077d85c8390eff878bf7d096d929a_cgraph">
<area shape="rect" title="Convert analog values to logic values by using a Schmitt&#45;trigger algorithm." alt="" coords="5,5,156,32"/>
<area shape="rect" href="a00069.html#ga7c692bc1d32dc9b126cd0d6bbf21f2bd" title="Convert an analog datafeed payload to an array of floats." alt="" coords="204,5,332,32"/>
</map>
</div>

</div>
</div>
<a id="a3f168ba982a19fb0e51254d5852e6572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f168ba982a19fb0e51254d5852e6572">&#9670;&nbsp;</a></span>sr_a2l_threshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sr_a2l_threshold </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="a00138.html">sr_datafeed_analog</a> *&#160;</td>
          <td class="paramname"><em>analog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert analog values to logic values by using a fixed threshold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">analog</td><td>The analog input values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">threshold</td><td>The threshold to use. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>The converted output values; either 0 or 1. Must provide space for count bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The number of samples to process.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SR_OK on success or SR_ERR on failure. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00011_source.html#l00044">44</a> of file <a class="el" href="a00011_source.html">conversion.c</a>.</p>

<p class="reference">References <a class="el" href="a00050_source.html#l00518">sr_datafeed_analog::data</a>, <a class="el" href="a00050_source.html#l00520">sr_datafeed_analog::encoding</a>, <a class="el" href="a00050_source.html#l00528">sr_analog_encoding::is_float</a>, <a class="el" href="a00002_source.html#l00177">sr_analog_to_float()</a>, <a class="el" href="a00050_source.html#l00068">SR_ERR</a>, and <a class="el" href="a00050_source.html#l00067">SR_OK</a>.</p>
<div id="dynsection-2" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-2-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-2-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-2-content" class="dyncontent" style="display:none;">
<div class="center"><img src="a00053_a3f168ba982a19fb0e51254d5852e6572_cgraph.png" border="0" usemap="#aa00053_a3f168ba982a19fb0e51254d5852e6572_cgraph" alt=""/></div>
<map name="aa00053_a3f168ba982a19fb0e51254d5852e6572_cgraph" id="aa00053_a3f168ba982a19fb0e51254d5852e6572_cgraph">
<area shape="rect" title="Convert analog values to logic values by using a fixed threshold." alt="" coords="5,5,123,32"/>
<area shape="rect" href="a00069.html#ga7c692bc1d32dc9b126cd0d6bbf21f2bd" title="Convert an analog datafeed payload to an array of floats." alt="" coords="171,5,299,32"/>
</map>
</div>

</div>
</div>
<a id="af6485cd6a98a0b05dec092b6b2a66e8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6485cd6a98a0b05dec092b6b2a66e8a">&#9670;&nbsp;</a></span>sr_resource_set_hooks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sr_resource_set_hooks </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="a00186.html">sr_context</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00053.html#a752a7d3375e2685e90893b1089d63972">sr_resource_open_callback</a>&#160;</td>
          <td class="paramname"><em>open_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00053.html#a51a8a2ac69656aabe68b54dab38288af">sr_resource_close_callback</a>&#160;</td>
          <td class="paramname"><em>close_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00053.html#aa98b4fba926e47164a1701658efe2550">sr_resource_read_callback</a>&#160;</td>
          <td class="paramname"><em>read_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install resource access hooks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>libsigrok context. Must not be NULL. </td></tr>
    <tr><td class="paramname">open_cb</td><td>Resource open callback, or NULL to unset. </td></tr>
    <tr><td class="paramname">close_cb</td><td>Resource close callback, or NULL to unset. </td></tr>
    <tr><td class="paramname">read_cb</td><td>Resource read callback, or NULL to unset. </td></tr>
    <tr><td class="paramname">cb_data</td><td>User data pointer passed to callbacks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">SR_OK</td><td>Success. </td></tr>
    <tr><td class="paramname">SR_ERR_ARG</td><td>Invalid argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>0.4.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00029_source.html#l00250">250</a> of file <a class="el" href="a00029_source.html">resource.c</a>.</p>

<p class="reference">References <a class="el" href="a00050_source.html#l00070">SR_ERR_ARG</a>.</p>

</div>
</div>
<a id="a0598bee8e091c1cfdf442d160c70e4e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0598bee8e091c1cfdf442d160c70e4e9">&#9670;&nbsp;</a></span>sr_resourcepaths_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSList* sr_resourcepaths_get </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>res_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of paths where we look for resource (e.g. </p>
<p>firmware) files.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res_type</td><td>The type of resource to get the search paths for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of strings that must be freed after use, including the strings.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.6.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00029_source.html#l00047">47</a> of file <a class="el" href="a00029_source.html">resource.c</a>.</p>

<p class="reference">References <a class="el" href="a00050_source.html#l00576">SR_RESOURCE_FIRMWARE</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Apr 15 2021 11:43:37 for libsigrok by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
