<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libsigrok: Input modules</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="libsigrok_112x112.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libsigrok
   &#160;<span id="projectnumber">unreleased development snapshot</span>
   </div>
   <div id="projectbrief">sigrok hardware access and backend library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Input modules</div>  </div>
</div><!--header-->
<div class="contents">

<p>Input file/data module handling.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga8741998692209adfd4e352e56a57b114"><td class="memItemLeft" align="right" valign="top">const struct sr_input_module **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00080.html#ga8741998692209adfd4e352e56a57b114">sr_input_list</a> (void)</td></tr>
<tr class="memdesc:ga8741998692209adfd4e352e56a57b114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a NULL-terminated list of all available input modules.  <a href="a00080.html#ga8741998692209adfd4e352e56a57b114">More...</a><br /></td></tr>
<tr class="separator:ga8741998692209adfd4e352e56a57b114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga072925b562704cb510449f2fee55f899"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00080.html#ga072925b562704cb510449f2fee55f899">sr_input_id_get</a> (const struct sr_input_module *imod)</td></tr>
<tr class="memdesc:ga072925b562704cb510449f2fee55f899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the specified input module's ID.  <a href="a00080.html#ga072925b562704cb510449f2fee55f899">More...</a><br /></td></tr>
<tr class="separator:ga072925b562704cb510449f2fee55f899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d106248a419623aa9a1fd5e37b2e8c5"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00080.html#ga3d106248a419623aa9a1fd5e37b2e8c5">sr_input_name_get</a> (const struct sr_input_module *imod)</td></tr>
<tr class="memdesc:ga3d106248a419623aa9a1fd5e37b2e8c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the specified input module's name.  <a href="a00080.html#ga3d106248a419623aa9a1fd5e37b2e8c5">More...</a><br /></td></tr>
<tr class="separator:ga3d106248a419623aa9a1fd5e37b2e8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga622935496493c2023a4563345a4c5c24"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00080.html#ga622935496493c2023a4563345a4c5c24">sr_input_description_get</a> (const struct sr_input_module *imod)</td></tr>
<tr class="memdesc:ga622935496493c2023a4563345a4c5c24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the specified input module's description.  <a href="a00080.html#ga622935496493c2023a4563345a4c5c24">More...</a><br /></td></tr>
<tr class="separator:ga622935496493c2023a4563345a4c5c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd755e2266d3c19536add2bda2cdb2cc"><td class="memItemLeft" align="right" valign="top">const char *const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00080.html#gadd755e2266d3c19536add2bda2cdb2cc">sr_input_extensions_get</a> (const struct sr_input_module *imod)</td></tr>
<tr class="memdesc:gadd755e2266d3c19536add2bda2cdb2cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the specified input module's file extensions typical for the file format, as a NULL terminated array, or returns a NULL pointer if there is no preferred extension.  <a href="a00080.html#gadd755e2266d3c19536add2bda2cdb2cc">More...</a><br /></td></tr>
<tr class="separator:gadd755e2266d3c19536add2bda2cdb2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab57b823af6c177edf93dab2d96299f8d"><td class="memItemLeft" align="right" valign="top">const struct sr_input_module *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00080.html#gab57b823af6c177edf93dab2d96299f8d">sr_input_find</a> (char *id)</td></tr>
<tr class="memdesc:gab57b823af6c177edf93dab2d96299f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the input module with the specified ID, or NULL if no module with that id is found.  <a href="a00080.html#gab57b823af6c177edf93dab2d96299f8d">More...</a><br /></td></tr>
<tr class="separator:gab57b823af6c177edf93dab2d96299f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga947b91ce69fc64cef5b4e72b3ddf4c5b"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="a00154.html">sr_option</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00080.html#ga947b91ce69fc64cef5b4e72b3ddf4c5b">sr_input_options_get</a> (const struct sr_input_module *imod)</td></tr>
<tr class="memdesc:ga947b91ce69fc64cef5b4e72b3ddf4c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a NULL-terminated array of struct <a class="el" href="a00154.html" title="Generic option struct used by various subsystems.">sr_option</a>, or NULL if the module takes no options.  <a href="a00080.html#ga947b91ce69fc64cef5b4e72b3ddf4c5b">More...</a><br /></td></tr>
<tr class="separator:ga947b91ce69fc64cef5b4e72b3ddf4c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7bccebee91a6991a65018a68b68c264"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00080.html#gae7bccebee91a6991a65018a68b68c264">sr_input_options_free</a> (const struct <a class="el" href="a00154.html">sr_option</a> **options)</td></tr>
<tr class="memdesc:gae7bccebee91a6991a65018a68b68c264"><td class="mdescLeft">&#160;</td><td class="mdescRight">After a call to <a class="el" href="a00080.html#ga947b91ce69fc64cef5b4e72b3ddf4c5b" title="Returns a NULL-terminated array of struct sr_option, or NULL if the module takes no options.">sr_input_options_get()</a>, this function cleans up all resources returned by that call.  <a href="a00080.html#gae7bccebee91a6991a65018a68b68c264">More...</a><br /></td></tr>
<tr class="separator:gae7bccebee91a6991a65018a68b68c264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga555801748623b935b60be3e662f9ea36"><td class="memItemLeft" align="right" valign="top">struct sr_input *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00080.html#ga555801748623b935b60be3e662f9ea36">sr_input_new</a> (const struct sr_input_module *imod, GHashTable *options)</td></tr>
<tr class="memdesc:ga555801748623b935b60be3e662f9ea36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new input instance using the specified input module.  <a href="a00080.html#ga555801748623b935b60be3e662f9ea36">More...</a><br /></td></tr>
<tr class="separator:ga555801748623b935b60be3e662f9ea36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d226bd14eb70973129c736e24ec905a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00080.html#ga3d226bd14eb70973129c736e24ec905a">sr_input_scan_buffer</a> (GString *buf, const struct sr_input **in)</td></tr>
<tr class="memdesc:ga3d226bd14eb70973129c736e24ec905a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to find an input module that can parse the given buffer.  <a href="a00080.html#ga3d226bd14eb70973129c736e24ec905a">More...</a><br /></td></tr>
<tr class="separator:ga3d226bd14eb70973129c736e24ec905a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57905453bc7b85d23e80862afb75e4d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00080.html#ga57905453bc7b85d23e80862afb75e4d4">sr_input_scan_file</a> (const char *filename, const struct sr_input **in)</td></tr>
<tr class="memdesc:ga57905453bc7b85d23e80862afb75e4d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to find an input module that can parse the given file.  <a href="a00080.html#ga57905453bc7b85d23e80862afb75e4d4">More...</a><br /></td></tr>
<tr class="separator:ga57905453bc7b85d23e80862afb75e4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga267353360cd2dfd9d4783a192de2ee09"><td class="memItemLeft" align="right" valign="top">const struct sr_input_module *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00080.html#ga267353360cd2dfd9d4783a192de2ee09">sr_input_module_get</a> (const struct sr_input *in)</td></tr>
<tr class="memdesc:ga267353360cd2dfd9d4783a192de2ee09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the input instance's module "class".  <a href="a00080.html#ga267353360cd2dfd9d4783a192de2ee09">More...</a><br /></td></tr>
<tr class="separator:ga267353360cd2dfd9d4783a192de2ee09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6021700cdb73e4c843c16f88f75beed"><td class="memItemLeft" align="right" valign="top">struct sr_dev_inst *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00080.html#gad6021700cdb73e4c843c16f88f75beed">sr_input_dev_inst_get</a> (const struct sr_input *in)</td></tr>
<tr class="memdesc:gad6021700cdb73e4c843c16f88f75beed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the input instance's (virtual) device instance.  <a href="a00080.html#gad6021700cdb73e4c843c16f88f75beed">More...</a><br /></td></tr>
<tr class="separator:gad6021700cdb73e4c843c16f88f75beed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada8138722494a8b7665749f5b3297805"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00080.html#gada8138722494a8b7665749f5b3297805">sr_input_send</a> (const struct sr_input *in, GString *buf)</td></tr>
<tr class="memdesc:gada8138722494a8b7665749f5b3297805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data to the specified input instance.  <a href="a00080.html#gada8138722494a8b7665749f5b3297805">More...</a><br /></td></tr>
<tr class="separator:gada8138722494a8b7665749f5b3297805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa887145d0ff9ce8aea3b9d9c4b5c0ea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00080.html#gaaa887145d0ff9ce8aea3b9d9c4b5c0ea">sr_input_end</a> (const struct sr_input *in)</td></tr>
<tr class="memdesc:gaaa887145d0ff9ce8aea3b9d9c4b5c0ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal the input module no more data will come.  <a href="a00080.html#gaaa887145d0ff9ce8aea3b9d9c4b5c0ea">More...</a><br /></td></tr>
<tr class="separator:gaaa887145d0ff9ce8aea3b9d9c4b5c0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedab9768c2587f4f14e456c25f55193d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00080.html#gaedab9768c2587f4f14e456c25f55193d">sr_input_reset</a> (const struct sr_input *in_ro)</td></tr>
<tr class="memdesc:gaedab9768c2587f4f14e456c25f55193d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the input module's input handling structures.  <a href="a00080.html#gaedab9768c2587f4f14e456c25f55193d">More...</a><br /></td></tr>
<tr class="separator:gaedab9768c2587f4f14e456c25f55193d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1d7eb09c7366fe32cc90191d08292eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00080.html#gaa1d7eb09c7366fe32cc90191d08292eb">sr_input_free</a> (const struct sr_input *in)</td></tr>
<tr class="memdesc:gaa1d7eb09c7366fe32cc90191d08292eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the specified input instance and all associated resources.  <a href="a00080.html#gaa1d7eb09c7366fe32cc90191d08292eb">More...</a><br /></td></tr>
<tr class="separator:gaa1d7eb09c7366fe32cc90191d08292eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Input file/data module handling. </p>
<p>libsigrok can process acquisition data in several different ways. Aside from acquiring data from a hardware device, it can also take it from a file in various formats (binary, CSV, VCD, and so on).</p>
<p>Like all libsigrok data handling, processing is done in a streaming manner: input should be supplied a chunk at a time. This way anything that processes data can do so in real time, without the user having to wait for the whole thing to be finished.</p>
<p>Every input module is "pluggable", meaning it's handled as being separate from the main libsigrok, but linked in to it statically. To keep things modular and separate like this, functions within an input module should be declared static, with only the respective 'struct sr_input_module' being exported for use into the wider libsigrok namespace. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga622935496493c2023a4563345a4c5c24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga622935496493c2023a4563345a4c5c24">&#9670;&nbsp;</a></span>sr_input_description_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* sr_input_description_get </td>
          <td>(</td>
          <td class="paramtype">const struct sr_input_module *&#160;</td>
          <td class="paramname"><em>imod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the specified input module's description. </p>
<dl class="section since"><dt>Since</dt><dd>0.4.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00059_source.html#l00137">137</a> of file <a class="el" href="a00059_source.html">input.c</a>.</p>

</div>
</div>
<a id="gad6021700cdb73e4c843c16f88f75beed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6021700cdb73e4c843c16f88f75beed">&#9670;&nbsp;</a></span>sr_input_dev_inst_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sr_dev_inst* sr_input_dev_inst_get </td>
          <td>(</td>
          <td class="paramtype">const struct sr_input *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the input instance's (virtual) device instance. </p>
<p>This can be used to find out the number of channels and other information.</p>
<p>If the device instance has not yet been fully populated by the input module, NULL is returned. This indicates the module needs more data to identify the number of channels and so on.</p>
<dl class="section since"><dt>Since</dt><dd>0.4.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00059_source.html#l00565">565</a> of file <a class="el" href="a00059_source.html">input.c</a>.</p>

</div>
</div>
<a id="gaaa887145d0ff9ce8aea3b9d9c4b5c0ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa887145d0ff9ce8aea3b9d9c4b5c0ea">&#9670;&nbsp;</a></span>sr_input_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sr_input_end </td>
          <td>(</td>
          <td class="paramtype">const struct sr_input *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signal the input module no more data will come. </p>
<p>This will cause the module to process any data it may have buffered. The SR_DF_END packet will also typically be sent at this time.</p>
<dl class="section since"><dt>Since</dt><dd>0.4.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00059_source.html#l00604">604</a> of file <a class="el" href="a00059_source.html">input.c</a>.</p>

</div>
</div>
<a id="gadd755e2266d3c19536add2bda2cdb2cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd755e2266d3c19536add2bda2cdb2cc">&#9670;&nbsp;</a></span>sr_input_extensions_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* const* sr_input_extensions_get </td>
          <td>(</td>
          <td class="paramtype">const struct sr_input_module *&#160;</td>
          <td class="paramname"><em>imod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the specified input module's file extensions typical for the file format, as a NULL terminated array, or returns a NULL pointer if there is no preferred extension. </p>
<dl class="section note"><dt>Note</dt><dd>these are a suggestions only.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.4.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00059_source.html#l00155">155</a> of file <a class="el" href="a00059_source.html">input.c</a>.</p>

</div>
</div>
<a id="gab57b823af6c177edf93dab2d96299f8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab57b823af6c177edf93dab2d96299f8d">&#9670;&nbsp;</a></span>sr_input_find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct sr_input_module* sr_input_find </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the input module with the specified ID, or NULL if no module with that id is found. </p>
<dl class="section since"><dt>Since</dt><dd>0.4.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00059_source.html#l00172">172</a> of file <a class="el" href="a00059_source.html">input.c</a>.</p>

</div>
</div>
<a id="gaa1d7eb09c7366fe32cc90191d08292eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1d7eb09c7366fe32cc90191d08292eb">&#9670;&nbsp;</a></span>sr_input_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sr_input_free </td>
          <td>(</td>
          <td class="paramtype">const struct sr_input *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the specified input instance and all associated resources. </p>
<dl class="section since"><dt>Since</dt><dd>0.4.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00059_source.html#l00669">669</a> of file <a class="el" href="a00059_source.html">input.c</a>.</p>

</div>
</div>
<a id="ga072925b562704cb510449f2fee55f899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga072925b562704cb510449f2fee55f899">&#9670;&nbsp;</a></span>sr_input_id_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* sr_input_id_get </td>
          <td>(</td>
          <td class="paramtype">const struct sr_input_module *&#160;</td>
          <td class="paramname"><em>imod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the specified input module's ID. </p>
<dl class="section since"><dt>Since</dt><dd>0.4.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00059_source.html#l00107">107</a> of file <a class="el" href="a00059_source.html">input.c</a>.</p>

</div>
</div>
<a id="ga8741998692209adfd4e352e56a57b114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8741998692209adfd4e352e56a57b114">&#9670;&nbsp;</a></span>sr_input_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct sr_input_module** sr_input_list </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a NULL-terminated list of all available input modules. </p>
<dl class="section since"><dt>Since</dt><dd>0.4.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00059_source.html#l00097">97</a> of file <a class="el" href="a00059_source.html">input.c</a>.</p>

</div>
</div>
<a id="ga267353360cd2dfd9d4783a192de2ee09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga267353360cd2dfd9d4783a192de2ee09">&#9670;&nbsp;</a></span>sr_input_module_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct sr_input_module* sr_input_module_get </td>
          <td>(</td>
          <td class="paramtype">const struct sr_input *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the input instance's module "class". </p>
<p>This can be used to find out which input module handles a specific input file. This is especially useful when an application did not create the input stream by specifying an input module, but instead some shortcut or convenience wrapper did.</p>
<dl class="section since"><dt>Since</dt><dd>0.6.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00059_source.html#l00547">547</a> of file <a class="el" href="a00059_source.html">input.c</a>.</p>

</div>
</div>
<a id="ga3d106248a419623aa9a1fd5e37b2e8c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d106248a419623aa9a1fd5e37b2e8c5">&#9670;&nbsp;</a></span>sr_input_name_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* sr_input_name_get </td>
          <td>(</td>
          <td class="paramtype">const struct sr_input_module *&#160;</td>
          <td class="paramname"><em>imod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the specified input module's name. </p>
<dl class="section since"><dt>Since</dt><dd>0.4.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00059_source.html#l00122">122</a> of file <a class="el" href="a00059_source.html">input.c</a>.</p>

</div>
</div>
<a id="ga555801748623b935b60be3e662f9ea36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga555801748623b935b60be3e662f9ea36">&#9670;&nbsp;</a></span>sr_input_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sr_input* sr_input_new </td>
          <td>(</td>
          <td class="paramtype">const struct sr_input_module *&#160;</td>
          <td class="paramname"><em>imod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GHashTable *&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new input instance using the specified input module. </p>
<p>This function is used when a client wants to use a specific input module to parse a stream. No effort is made to identify the format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">imod</td><td>The input module to use. Must not be NULL. </td></tr>
    <tr><td class="paramname">options</td><td>GHashTable consisting of keys corresponding with the module options <code>id</code> field. The values should be GVariant pointers with sunk references, of the same GVariantType as the option's default value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>0.4.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00059_source.html#l00255">255</a> of file <a class="el" href="a00059_source.html">input.c</a>.</p>

<p class="reference">References <a class="el" href="a00050_source.html#l00567">sr_option::def</a>, <a class="el" href="a00050_source.html#l00561">sr_option::id</a>, and <a class="el" href="a00050_source.html#l00067">SR_OK</a>.</p>

</div>
</div>
<a id="gae7bccebee91a6991a65018a68b68c264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7bccebee91a6991a65018a68b68c264">&#9670;&nbsp;</a></span>sr_input_options_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sr_input_options_free </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="a00154.html">sr_option</a> **&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>After a call to <a class="el" href="a00080.html#ga947b91ce69fc64cef5b4e72b3ddf4c5b" title="Returns a NULL-terminated array of struct sr_option, or NULL if the module takes no options.">sr_input_options_get()</a>, this function cleans up all resources returned by that call. </p>
<dl class="section since"><dt>Since</dt><dd>0.4.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00059_source.html#l00220">220</a> of file <a class="el" href="a00059_source.html">input.c</a>.</p>

<p class="reference">References <a class="el" href="a00050_source.html#l00567">sr_option::def</a>, and <a class="el" href="a00050_source.html#l00569">sr_option::values</a>.</p>

</div>
</div>
<a id="ga947b91ce69fc64cef5b4e72b3ddf4c5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga947b91ce69fc64cef5b4e72b3ddf4c5b">&#9670;&nbsp;</a></span>sr_input_options_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="a00154.html">sr_option</a>** sr_input_options_get </td>
          <td>(</td>
          <td class="paramtype">const struct sr_input_module *&#160;</td>
          <td class="paramname"><em>imod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a NULL-terminated array of struct <a class="el" href="a00154.html" title="Generic option struct used by various subsystems.">sr_option</a>, or NULL if the module takes no options. </p>
<p>Each call to this function must be followed by a call to <a class="el" href="a00080.html#gae7bccebee91a6991a65018a68b68c264" title="After a call to sr_input_options_get(), this function cleans up all resources returned by that call.">sr_input_options_free()</a>.</p>
<dl class="section since"><dt>Since</dt><dd>0.4.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00059_source.html#l00193">193</a> of file <a class="el" href="a00059_source.html">input.c</a>.</p>

<p class="reference">References <a class="el" href="a00050_source.html#l00561">sr_option::id</a>.</p>

</div>
</div>
<a id="gaedab9768c2587f4f14e456c25f55193d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedab9768c2587f4f14e456c25f55193d">&#9670;&nbsp;</a></span>sr_input_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sr_input_reset </td>
          <td>(</td>
          <td class="paramtype">const struct sr_input *&#160;</td>
          <td class="paramname"><em>in_ro</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the input module's input handling structures. </p>
<p>Causes the input module to reset its internal state so that we can re-send the input data from the beginning without having to re-create the entire input module.</p>
<dl class="section since"><dt>Since</dt><dd>0.5.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00059_source.html#l00619">619</a> of file <a class="el" href="a00059_source.html">input.c</a>.</p>

<p class="reference">References <a class="el" href="a00050_source.html#l00070">SR_ERR_ARG</a>, and <a class="el" href="a00050_source.html#l00067">SR_OK</a>.</p>

</div>
</div>
<a id="ga3d226bd14eb70973129c736e24ec905a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d226bd14eb70973129c736e24ec905a">&#9670;&nbsp;</a></span>sr_input_scan_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sr_input_scan_buffer </td>
          <td>(</td>
          <td class="paramtype">GString *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct sr_input **&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to find an input module that can parse the given buffer. </p>
<p>The buffer must contain enough of the beginning of the file for the input modules to find a match. This is format-dependent. When magic strings get checked, 128 bytes normally could be enough. Note that some formats try to parse larger header sections, and benefit from seeing a larger scope.</p>
<p>If an input module is found, an instance is created into *in. Otherwise, *in contains NULL. When multiple input moduless claim support for the format, the one with highest confidence takes precedence. Applications will see at most one input module spec.</p>
<p>If an instance is created, it has the given buffer used for scanning already submitted to it, to be processed before more data is sent. This allows a frontend to submit an initial chunk of a non-seekable stream, such as stdin, without having to keep it around and submit it again later. </p>

<p class="definition">Definition at line <a class="el" href="a00059_source.html#l00364">364</a> of file <a class="el" href="a00059_source.html">input.c</a>.</p>

</div>
</div>
<a id="ga57905453bc7b85d23e80862afb75e4d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57905453bc7b85d23e80862afb75e4d4">&#9670;&nbsp;</a></span>sr_input_scan_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sr_input_scan_file </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct sr_input **&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to find an input module that can parse the given file. </p>
<p>If an input module is found, an instance is created into *in. Otherwise, *in contains NULL. When multiple input moduless claim support for the format, the one with highest confidence takes precedence. Applications will see at most one input module spec. </p>

<p class="definition">Definition at line <a class="el" href="a00059_source.html#l00442">442</a> of file <a class="el" href="a00059_source.html">input.c</a>.</p>

<p class="reference">References <a class="el" href="a00050_source.html#l00068">SR_ERR</a>, and <a class="el" href="a00050_source.html#l00070">SR_ERR_ARG</a>.</p>

</div>
</div>
<a id="gada8138722494a8b7665749f5b3297805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada8138722494a8b7665749f5b3297805">&#9670;&nbsp;</a></span>sr_input_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sr_input_send </td>
          <td>(</td>
          <td class="paramtype">const struct sr_input *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GString *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send data to the specified input instance. </p>
<p>When an input module instance is created with <a class="el" href="a00080.html#ga555801748623b935b60be3e662f9ea36" title="Create a new input instance using the specified input module.">sr_input_new()</a>, this function is used to feed data to the instance.</p>
<p>As enough data gets fed into this function to completely populate the device instance associated with this input instance, this is guaranteed to return the moment it's ready. This gives the caller the chance to examine the device instance, attach session callbacks and so on.</p>
<dl class="section since"><dt>Since</dt><dd>0.4.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00059_source.html#l00587">587</a> of file <a class="el" href="a00059_source.html">input.c</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Apr 15 2021 11:43:37 for libsigrok by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
